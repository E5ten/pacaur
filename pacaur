#!/bin/bash
#
# pacaur: an AUR helper that minimizes user interaction
#

shopt -s extglob

# gettext initialization
export LC_COLLATE='C'
export TEXTDOMAIN='pacaur'
export TEXTDOMAINDIR='/usr/share/locale'

declare -r version='4.8.6'

#
# Config
#

# Options
aur=0 asdeps=0 asexplicit=0 checkdeps=0 cleancache=0 ccount=0 color='' dcount=0
devel=0 downloadonly=0 help=0 info=0 installpkg=0 native=0 needed=0 noconfirm=0
nodeps=0 noedit=0 noop=0 operation='' pac=0 pace=0 pacQ=0 pacS=0 rebuild=0
refresh=0 repo=0 search=0 upgrade=0 ver=0 QUIET=0
pacmanarg=() pacopts=() auropts=() makeopts=()

# determine config location
while IFS=':' read -rd: i; do
    if [[ -d "${i}/pacaur" ]]; then
        configdir="${i}/pacaur"
        break
    fi
done <<<"${XDG_CONFIG_DIRS:-/etc/xdg}:"
declare -r configdir="${configdir:-/etc/xdg/pacaur}" userconfigdir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacaur" \
    userpacmandir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacman" \
    usercachedir="${XDG_CACHE_HOME:-${HOME}/.cache}/pacaur" tmpdir="${XDG_RUNTIME_DIR:-/tmp}"

# preserve environment variables
var=('PACMAN' {'PKG','SRC'}{'DEST','EXT'} {'SRCPKG','LOG'}'DEST' 'BUILDDIR' 'GPGKEY' 'PACKAGER' 'CARCH')
for i in "${var[@]}"; do
    [[ ! "${!i-}" ]] || declare _"${i}"="${!i}"
done
PKGDEST="${PKGDEST:-}"

# source makepkg variables
if [[ -r "${MAKEPKG_CONF-}" ]]; then
    source "${MAKEPKG_CONF}"
else
    source /etc/makepkg.conf
    if [[ -r "${userpacmandir}/makepkg.conf" ]]; then
        source "${userpacmandir}/makepkg.conf"
    elif [[ -r "${HOME}/.makepkg.conf" ]]; then
        source "${HOME}/.makepkg.conf"
    fi
fi

# restore environment variables
for i in "${var[@]/#/_}"; do
    [[ ! "${!i-}" ]] || { j="${i#_}"; declare -x "${i#_}"="${!i:-${!j}}"; unset j; }
done

# set default config variables
editor="${VISUAL:-${EDITOR:-vi}}"           # build files editor
displaybuildfiles='diff'                    # display build files (none|diff|full)
silent='false'                              # silence output
sortby='name'                               # sort method (name|votes|popularity)
sortorder='ascending'                       # sort order (ascending|descending)
sudoloop='true'                             # prevent sudo timeout

# set variables
declare -r pacmanbin="${PACMAN:-pacman}"            # pacman binary
declare -r clonedir="${AURDEST:-${usercachedir:?}}" # clone directory

# source xdg config
[[ ! -r "${configdir}/config" ]] || source "${configdir}/config"
[[ ! -r "${userconfigdir}/config" ]] || source "${userconfigdir}/config"

# source makepkg libraries
for i in parseopts util option error; do
    source "/usr/share/makepkg/util/${i}.sh"
done
check_buildoption check n || checkdeps=1

# determine whether we have gettext; make it a no-op if we do not
type -p gettext >/dev/null || gettext() { printf '%s\n' "$@"; }

declare -r vcs='-@(cvs|svn|git|hg|bzr|darcs|daily*|nightly*)' # vcs package glob

[[ -d "${clonedir}" && -w "${clonedir}" ]] || mkdir -p "${clonedir}" # setup clonedir

#
# Functions
#

ClassifyPkgs() {
    local noaurpkgs=() norepopkgs=()
    # global aurpkgs repopkgs
    ((! repo)) || repopkgs=("${pkgs[@]}")
    ((! aur)) || aurpkgs=("${pkgs[@]#aur/}") # search aur/pkgs in AUR
    if ((! repo && ! aur)); then
        for i in "${pkgs[@]}"; do
            if [[ "${i}" = 'aur/'* ]]; then
                aurpkgs+=("${i:4}") # search aur/pkgs in AUR
                continue
            fi
            noaurpkgs+=("${i}")
        done
        [[ "${noaurpkgs[*]}" ]] &&
            mapfile -t norepopkgs < <(LC_ALL='C' "${pacmanbin}" -Sp "${noaurpkgs[@]}" 2>&1 >/dev/null)
            norepopkgs=("${norepopkgs[@]#error: target not found: }")
        for i in "${norepopkgs[@]}"; do # do not search repo/pkgs in AUR
            [[ " ${noaurpkgs[*]} " = *' '+([a-zA-Z0-9.+-])"/${i} "* ]] || aurpkgs+=("${i}")
        done
        mapfile -t repopkgs < <(CommArr 'aurpkgs' 'noaurpkgs' '-13')
    fi
}

Core() {
    GetIgnoredPkgs
    GetIgnoredGrps
    ((! upgrade)) || UpgradeAur
    IgnoreChecks
    DepsSolver
    IgnoreDepsChecks
    ProviderChecks
    ConflictChecks
    ReinstallChecks
    OutOfDateChecks
    OrphanChecks
    Prompt
    MakePkgs
}

UpgradeAur() {
    local foreignpkgs allaurpkgs aurforeignpkgs i
    # global aurpkgs
    info $"%sStarting AUR upgrade...%s" "${colorW}" "${reset}"
    mapfile -t foreignpkgs < <("${pacmanbin}" -Qmq)
    SetInfo "${foreignpkgs[@]}"
    mapfile -t allaurpkgs < <(GetInfo Name)

    # foreign packages check
    mapfile -t aurforeignpkgs < <(CommArr 'allaurpkgs' 'foreignpkgs' '-13')
    for i in "${aurforeignpkgs[@]}"; do
        warn $"%s is %snot present%s in AUR -- skipping" "${colorW}${i}${reset}" "${colorY}" "${reset}"
    done

    # use auracle to find out of date AUR packages
    mapfile -t aurpkgs < <(auracle sync -q)

    # add devel packages
    if ((devel)); then
        for i in "${allaurpkgs[@]}"; do
            [[ "${i}" = *${vcs} && " ${aurpkgs[*]} " != *" ${i} "* ]] && aurpkgs+=("${i}")
        done
    fi

    aurpkgs+=("${pkgs[@]}")

    # avoid possible duplicate
    aurpkgs=($(printf '%s\n' "${aurpkgs[@]}" | sort -u))

    NothingToDo "${aurpkgs[@]}"
}

IgnoreChecks() {
    local checkaurpkgs checkaurpkgsAver checkaurpkgsQver checkaurpkgsgrp i
    # global aurpkgs rmaurpkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # check targets
    SetInfo "${aurpkgsnover[@]}"
    mapfile -t checkaurpkgs < <(GetInfo Name)
    mapfile -t errdeps < <(CommArr 'aurpkgsnover' 'checkaurpkgs' '-3')
    aurpkgsnover=()

    mapfile -t checkaurpkgsAver < <(GetInfo Version)
    mapfile -t checkaurpkgsQver < <(expac -Qv '%v' "${checkaurpkgs[@]}" 2>&1)
    for i in "${!checkaurpkgs[@]}"; do
        [[ "${checkaurpkgs[i]}" != *${vcs} ]] || checkaurpkgsAver[i]=$"latest"
        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" ${checkaurpkgs[i]} "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            checkaurpkgsgrp=($(GetInfo Groups "${checkaurpkgs[i]}"))
            mapfile -tO "${#checkaurpkgsgrp[@]}" checkaurpkgsgrp < <(expac -Ql'\n' '%G' "${checkaurpkgs[i]}")
            for j in "${checkaurpkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " != *" ${j} "* ]] || isignored=1
            done
        fi

        if ((isignored)); then
            if ((! upgrade)); then
                if ((! noconfirm)); then
                    if ! Proceed y $"%s is in IgnorePkg/IgnoreGroup. Install anyway?" "${checkaurpkgs[i]}"; then
                        warn $"skipping target: %s" "${colorW}${checkaurpkgs[i]}${reset}"
                        rmaurpkgs+=("${checkaurpkgs[i]}")
                        continue
                    fi
                else
                    warn $"skipping target: %s" "${colorW}${checkaurpkgs[i]}${reset}"
                    rmaurpkgs+=("${checkaurpkgs[i]}")
                    continue
                fi
            else
                warn $"%s: ignoring package upgrade (%s => %s)" "${colorW}${checkaurpkgs[i]}${reset}" \
                    "${colorR}${checkaurpkgsQver[i]}${reset}" "${colorG}${checkaurpkgsAver[i]}${reset}"
                rmaurpkgs+=("${checkaurpkgs[i]}")
                continue
            fi
        fi
        aurpkgsnover+=("${checkaurpkgs[i]}")
    done

    aurpkgs=("${aurpkgsnover[@]}")
    NothingToDo "${aurpkgs[@]}"
}

DepsSolver() {
    local i aurpkgsconflicts
    # global aurpkgs aurpkgsnover aurpkgsproviders aurdeps deps errdeps
    # global errdepsnover foreignpkgs repodeps depsAname depsAver depsAood depsQver
    printf '%s\n' $"resolving dependencies..."

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # set unversioned info
    SetInfo "${aurpkgsnover[@]}"

    # set targets providers
    aurpkgsproviders=("${aurpkgsnover[@]}")
    aurpkgsproviders+=($(GetInfo Provides))
    aurpkgsproviders=("${aurpkgsproviders[@]%%[><=]*}")

    # check targets conflicts
    aurpkgsconflicts=($(GetInfo Conflicts))
    if [[ "${aurpkgsconflicts[*]}" ]]; then
        aurpkgsconflicts=("${aurpkgsconflicts[@]%%[><=]*}")
        mapfile -t aurpkgsconflicts < <(CommArr 'aurpkgsproviders' 'aurpkgsconflicts' '-12')
        for i in "${aurpkgsconflicts[@]}"; do
            [[ " ${aurpkgsnover[*]} " = *" ${i} "* ]] || continue
            [[ " $(GetInfo Conflicts "${i}") " != *" ${i} "* ]] || continue
            fail $"unresolvable package conflicts detected"
            error $"failed to prepare transaction (conflicting dependencies: %s)" "${i}" \
                "${E_INSTALL_DEPS_FAILED}"
        done
    fi

    deps=("${aurpkgsnover[@]}")

    [[ "${foreignpkgs[*]}" ]] || mapfile -t foreignpkgs < <("${pacmanbin}" -Qmq)
    FindDepsAur "${aurpkgsnover[@]}"

    # avoid possible duplicate
    mapfile -t deps < <(CommArr 'aurdepspkgs' 'deps' '-13')
    deps+=("${aurdepspkgs[@]}")

    # ensure correct dependency order
    SetInfo "${deps[@]}"
    SortDepsAur "${aurpkgs[@]}"
    mapfile -t deps < <(tsort <<< "${tsortdeps[@]}" 2>/dev/null)
    wait "$!" || error $"dependency cycle detected" "${E_INSTALL_DEPS_FAILED}"

    # get AUR packages info
    mapfile -t depsAname < <(GetInfo Name)
    mapfile -t depsAver < <(GetInfo Version)
    mapfile -t depsAood < <(GetInfo OutOfDate)
    mapfile -t depsAmain < <(GetInfo Maintainer)
    for i in "${!depsAname[@]}"; do
        read -rd' ' depsQver[i] < <(expac -Qs '%v' "^${depsAname[i]}$")
        [[ "${depsQver[i]}" ]] || depsQver[i]='%' # avoid empty elements shift
        [[ "${depsAname[i]}" != *${vcs} ]] || depsAver[i]=$"latest"
    done

    # no results check
    if [[ "${errdeps[*]}" ]]; then
        for i in "${!errdepsnover[@]}"; do
            if [[ " ${aurpkgsnover[*]} " = *" ${errdepsnover[i]} "* ]]; then
                fail $"no results found for %s" "${errdeps[i]}"
            else
                unset tsorterrdeps errdepslist currenterrdep
                # find relevant tsorted deps chain
                for j in "${deps[@]}"; do
                    tsorterrdeps+=("${j}")
                    [[ "${j}" != "${errdepsnover[i]}" ]] || break
                done
                # reverse deps order
                for j in "${!tsorterrdeps[@]}"; do
                    tsorterrdepsrev[j]="${tsorterrdeps[-j-1]}"
                done
                tsorterrdeps=("${tsorterrdepsrev[@]}"); unset tsorterrdepsrev
                errdepslist+=("${tsorterrdeps[0]}")
                FindDepsAurError "${tsorterrdeps[@]}"
                for j in "${!errdepslist[@]}"; do
                    [[ "${errdepslist[-j-1]}" ]] && errdepslistrev+=("${errdepslist[-j-1]}")
                done
                errdepslist=("${errdepslistrev[@]}"); unset errdepslistrev
                fail $"no results found for %s (dependency tree: %s)" "${errdeps[i]}" "${errdepslist[*]}"
            fi
        done
        exit "${E_INSTALL_DEPS_FAILED}"
    fi

    # return all binary deps
    FindDepsRepo "${repodeps[@]}"

    # avoid possible duplicate
    repodepspkgs=($(printf '%s\n' "${repodepspkgs[@]}" | sort -u))
}

FindDepsAur() {
    local depAname depAver depspkgs depspkgsaurtmp builtpkg vcsdepspkgs assumedepspkgs aurversionpkgs
    local aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff i j
    # global aurpkgsnover depspkgsaur errdeps repodeps aurdepspkgs prevdepspkgsaur foreignpkgs
    ((nodeps && dcount >= 2)) && return

    # set info
    unset aurversionpkgs
    if [[ "${depspkgsaur[*]}" ]]; then
        SetInfo "${depspkgsaur[@]}"
        aurversionpkgs=("${prevdepspkgsaur[@]}")
    else
        SetInfo "${aurpkgsnover[@]}"
        aurversionpkgs=("${aurpkgs[@]}")
    fi

    # versioning check
    if [[ "${aurversionpkgs[*]}" ]]; then
        for i in "${!aurversionpkgs[@]}"; do
            unset aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff
            aurversionpkgsname="${aurversionpkgs[i]%%[><=]*}"
            aurversionpkgsver="${aurversionpkgs[i]##*[><=]}"
            aurversionpkgsaurver="$(GetInfo Version "${aurversionpkgsname}")"
            aurversionpkgsverdiff="$(vercmp "${aurversionpkgsaurver}" "${aurversionpkgsver}")"

            # not found in AUR nor repo
            [[ "${aurversionpkgsaurver}" || " ${errdeps[*]} " = *" ${aurversionpkgs[i]} "* ]] ||
                { errdeps+=("${aurversionpkgs[i]}"); continue; }

            case "${aurversionpkgs[i]}" in
                *">"*|*"<"*|*"="*)
                    # found in AUR but version not correct
                    case "${aurversionpkgs[i]}" in
                        *">="*) ((aurversionpkgsverdiff >= 0)) && continue;;
                        *"<="*) ((aurversionpkgsverdiff <= 0)) && continue;;
                        *">"*)  ((aurversionpkgsverdiff > 0))  && continue;;
                        *"<"*)  ((aurversionpkgsverdiff < 0))  && continue;;
                        *"="*)  ((aurversionpkgsverdiff == 0)) && continue;;
                    esac
                    [[ " ${errdeps[*]} " = *" ${aurversionpkgs[i]} "* ]] ||
                        errdeps+=("${aurversionpkgs[i]}");;
                *) continue;;
            esac
        done
    fi

    depspkgs=($(GetInfo Depends))

    # cached packages makedeps check
    if [[ ! "${PKGDEST}" ]] || ((rebuild)); then
        depspkgs+=($(GetInfo MakeDepends))
        ((checkdeps)) && depspkgs+=($(GetInfo CheckDepends))
    else
        [[ ! "${depspkgsaur[*]}" ]] && depspkgsaurtmp=("${aurpkgs[@]}") ||
            depspkgsaurtmp=("${depspkgsaur[@]}")
        for i in "${!depspkgsaurtmp[@]}"; do
            depAname="$(GetInfo Name "${depspkgsaurtmp[i]}")"
            depAver="$(GetInfo Version "${depspkgsaurtmp[i]}")"
            GetBuiltPkg "${depAname}-${depAver}" "${PKGDEST}"
            if [[ ! "${builtpkg}" ]]; then
                depspkgs+=($(GetInfo MakeDepends "${depspkgsaurtmp[i]}"))
                ((checkdeps)) && depspkgs+=($(GetInfo CheckDepends "${depspkgsaurtmp[i]}"))
            fi
            unset builtpkg
        done
    fi

    # remove deps provided by targets
    [[ "${aurpkgsproviders[*]}" ]] && mapfile -t depspkgs < <(CommArr 'aurpkgsproviders' 'depspkgs' '-13')

    # workaround for limited RPC support of architecture dependent fields
    if [[ "${CARCH}" = 'i686' ]]; then
        for i in "${!depspkgs[@]}"; do
            [[ "${depspkgs[i]}" != @(lib32-|gcc-multilib)* ]] || unset 'depspkgs[i]'
        done
        depspkgs=("${depspkgs[@]}")
    fi

    # remove versioning
    depspkgs=("${depspkgs[@]%%[><=]*}")
    # remove installed deps
    if ((! devel)); then
        mapfile -t depspkgs < <("${pacmanbin}" -T -- "${depspkgs[@]}" | sort -u)
    else
        # check providers
        unset vcsdepspkgs
        for i in "${!depspkgs[@]}"; do
            read -rd' ' j < <(expac -Qs '%n %P' "^${depspkgs[i]}$")
            if [[ "${j}" ]]; then
                depspkgs[i]="${j}"
                ((devel)) && [[ " ${ignoredpkgs[*]} " != *" ${j} "* && "${j}" = *${vcs} ]] &&
                    vcsdepspkgs+=("${j}")
            else
                foreignpkgs+=("${depspkgs[i]}")
            fi
        done
        # reorder devel
        mapfile -t depspkgs < <("${pacmanbin}" -T -- "${depspkgs[@]}" | sort -u)
        mapfile -t depspkgs < <(CommArr 'depspkgs' 'vcsdepspkgs' '-3')
    fi

    # split repo and AUR depends pkgs
    unset depspkgsaur
    if [[ "${depspkgs[*]}" ]]; then
        # remove all pkgs versioning
        if ((nodeps && dcount == 1)); then
            depspkgs=("${depspkgs[@]%%[><=]*}")
        # assume installed deps
        elif [[ "${assumeinstalled[*]}" ]]; then
            # remove versioning
            assumeinstalled=("${assumeinstalled[@]%%[><=]*}")
            for i in "${!assumeinstalled[@]}"; do
                unset assumedepspkgs
                for j in "${!depspkgs[@]}"; do
                    assumedepspkgs[j]="${depspkgs[j]%%[><=]*}"
                    [[ " ${assumedepspkgs[*]} " = *" ${assumeinstalled[i]} "* ]] &&
                        depspkgs[j]="${assumeinstalled[i]}";
                done
            done
            mapfile -t depspkgs < <(CommArr 'assumeinstalled' 'depspkgs' '-13')
        fi
        if [[ "${depspkgs[*]}" ]]; then
            mapfile -t depspkgsaur < <(LC_ALL='C' "${pacmanbin}" -Sp "${depspkgs[@]}" 2>&1 >/dev/null) &&
                depspkgsaur=("${depspkgsaur[@]#error: target not found: }")
            mapfile -tO "${#repodeps[@]}" repodeps < <(CommArr 'depspkgsaur' 'depspkgs' '-13')
        fi
    fi
    unset depspkgs

    # remove duplicate
    [[ "${depspkgsaur[*]}" ]] && mapfile -t depspkgsaur < <(CommArr 'aurdepspkgs' 'depspkgsaur' '-13')

    # dependency cycle check
    [[ "${prevdepspkgsaur[*]}" && "${prevdepspkgsaur[*]}" = "${depspkgsaur[*]}" ]] &&
        error $"dependency cycle detected (%s)" "${depspkgsaur[*]}" "${E_INSTALL_DEPS_FAILED}"

    if [[ "${depspkgsaur[*]}" ]]; then
        # store for AUR version check
        ((nodeps)) || prevdepspkgsaur=("${depspkgsaur[@]}")
        # remove duplicates and versioning
        depspkgsaur=($(printf '%s\n' "${depspkgsaur[@]%%[><=]*}" | sort -u))
    fi

    [[ "${depspkgsaur[*]}" ]] && aurdepspkgs+=("${depspkgsaur[@]}") &&
        FindDepsAur "${depspkgsaur[@]}"
}

SortDepsAur() {
    local i j sortaurpkgs sortdepspkgs sortdepspkgsaur
    # global checkedsortdepspkgsaur allcheckedsortdepspkgsaur errdepsnover
    [[ "${checkedsortdepspkgsaur[*]}" ]] && sortaurpkgs=("${checkedsortdepspkgsaur[@]}") ||
        sortaurpkgs=("${aurpkgs[@]}")

    unset checkedsortdepspkgsaur
    for i in "${!sortaurpkgs[@]}"; do
        unset sortdepspkgs sortdepspkgsaur

        sortdepspkgs+=($(GetInfo Depends "${sortaurpkgs[i]}"))
        sortdepspkgs+=($(GetInfo MakeDepends "${sortaurpkgs[i]}"))
        ((checkdeps)) && sortdepspkgs+=($(GetInfo CheckDepends "${sortaurpkgs[i]}"))

        # remove versioning
        errdepsnover=("${errdeps[@]%%[><=]*}")

        # check AUR deps only
        for j in "${!sortdepspkgs[@]}"; do
            sortdepspkgs[j]="${sortdepspkgs[j]%%[><=]*}"
            sortdepspkgsaur+=($(GetInfo Name "${sortdepspkgs[j]}"))
            # add erroneous AUR deps
            [[ " ${errdepsnover[*]} " = *" ${sortdepspkgs[j]} "* ]] && sortdepspkgsaur+=("${sortdepspkgs[j]}")
        done

        # prepare tsort list
        if [[ ! "${sortdepspkgsaur[*]}" ]]; then
            tsortdeps+=("${sortaurpkgs[i]} ${sortaurpkgs[i]}")
        else
            for j in "${!sortdepspkgsaur[@]}"; do
                tsortdeps+=("${sortaurpkgs[i]} ${sortdepspkgsaur[j]}")
            done
        fi

        # filter non checked deps
        mapfile -t sortdepspkgsaur < <(CommArr 'allcheckedsortdepspkgsaur' 'sortdepspkgsaur' '-13')
        if [[ "${sortdepspkgsaur[*]}" ]]; then
            checkedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur=($(printf '%s\n' "${allcheckedsortdepspkgsaur[@]}" | sort -u))
        fi
    done
    if [[ "${checkedsortdepspkgsaur[*]}" ]]; then
        checkedsortdepspkgsaur=($(printf '%s\n' "${checkedsortdepspkgsaur[@]}" | sort -u))
        SortDepsAur "${checkedsortdepspkgsaur[@]}"
    fi
}

FindDepsAurError() {
    local i nexterrdep nextallerrdeps
    # global errdepsnover errdepslist tsorterrdeps currenterrdep

    for i in "${tsorterrdeps[@]}"; do
        [[ " ${errdepsnover[*]} " = *" ${i} "* || " ${errdepslist[*]} " = *" ${i} "* ]] && break ||
            nexterrdep="${i}"
    done

    [[ "${currenterrdep[*]}" ]] || currenterrdep="${tsorterrdeps[0]}"
    if [[ " ${aurpkgs[*]} " != *" ${nexterrdep} "* ]]; then
        nextallerrdeps=($(GetInfo Depends "${nexterrdep}"))
        nextallerrdeps+=($(GetInfo MakeDepends "${nexterrdep}"))
        ((checkdeps)) && nextallerrdeps+=($(GetInfo CheckDepends "${nexterrdep}"))

        # remove versioning
        nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

        [[ " ${nextallerrdeps[*]} " = *" ${currenterrdep} "* ]] && errdepslist+=("${nexterrdep}") \
            currenterrdep="${tsorterrdeps[0]}"
        tsorterrdeps=("${tsorterrdeps[@]:1}")
        FindDepsAurError "${tsorterrdeps[@]}"
    else
        for i in "${!aurpkgs[@]}"; do
            nextallerrdeps=($(GetInfo Depends "${aurpkgs[i]}"))
            nextallerrdeps+=($(GetInfo MakeDepends "${aurpkgs[i]}"))
            ((checkdeps)) && nextallerrdeps+=($(GetInfo CheckDepends "${aurpkgs[i]}"))

            # remove versioning
            nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

            [[ " ${nextallerrdeps[*]} " = *" ${currenterrdep} "* ]] && errdepslist+=("${aurpkgs[i]}")
        done
    fi
}

FindDepsRepo() {
    local allrepodepspkgs repodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${repodeps[*]}" ]] || return

    # reduce root binary deps
    repodeps=($(printf '%s\n' "${repodeps[@]}" | sort -u))

    # add initial repodeps
    [[ "${repodepspkgs[*]}" ]] || repodepspkgs=("${repodeps[@]}")

    # get non installed binary deps
    unset allrepodepspkgs repodepspkgstmp
    # no version check needed as all deps are repo deps
    [[ ! "${repodeps[*]}" ]] || mapfile -t allrepodepspkgs < <(expac -S1l'\n' '%E' "${repodeps[@]}")
    [[ ! "${allrepodepspkgs[*]}" ]] ||
        mapfile -t repodepspkgstmp < <("${pacmanbin}" -T -- "${allrepodepspkgs[@]}" | sort -u)

    # remove duplicate
    [[ ! "${repodepspkgstmp[*]}" ]] || mapfile -t repodepspkgstmp < <(CommArr 'repodepspkgs'{,'tmp'} '-13')
    [[ ! "${repodepspkgstmp[*]}" ]] || { repodepspkgs+=("${repodepspkgstmp[@]}")
        repodeps=("${repodepspkgstmp[@]}"); FindDepsRepo "${repodeps[@]}"; }
}

FindDepsRepoProvider() {
    local allrepodepspkgs providerrepodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${providerspkgs[*]}" ]] || return

    # reduce root binary deps
    providerspkgs=($(printf '%s\n' "${providerspkgs[@]}" | sort -u))

    # get non installed repo deps
    unset allproviderrepodepspkgs providerrepodepspkgstmp
    [[ ! "${providerspkgs[*]}" ]] ||
        mapfile -t allproviderrepodepspkgs < <(expac -S1l'\n' '%E' "${providerspkgs[@]}")
    # no version check needed as all deps are binary
    [[ "${allproviderrepodepspkgs[*]}" ]] &&
        mapfile -t providerrepodepspkgstmp < <("${pacmanbin}" -T -- "${allproviderrepodepspkgs[@]}" | sort -u)

    # remove duplicate
    [[ "${providerrepodepspkgstmp[*]}" ]] &&
        mapfile -t providerrepodepspkgstmp < <(CommArr 'repodepspkgs' 'providerrepodepspkgstmp' '-13')

    [[ ! "${providerrepodepspkgstmp[*]}" ]] || { repodepspkgs+=("${providerrepodepspkgstmp[@]}")
        providerspkgs=("${providerrepodepspkgstmp[@]}"); FindDepsRepoProvider "${providerspkgs[@]}"; }
}

IgnoreDepsChecks() {
    local i
    # global ignoredpkgs aurpkgs aurdepspkgs aurdepspkgsgrp repodepspkgsgrp rmaurpkgs deps repodepspkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # add checked targets and preserve tsorted order
    deps=("${deps[@]:0:${#aurpkgs[@]}}")

    # check dependencies
    for i in "${repodepspkgs[@]}"; do
        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" ${i} "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset repodepspkgsSgrp repodepspkgsQgrp
            mapfile -t repodepspkgsgrp < <(expac -S1l'\n' '%G' "${i}")
            mapfile -tO "${#repodepspkgsgrp[@]}" repodepspkgsgrp < <(expac -Ql'\n' '%G' "${i}")
            for j in "${repodepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " = *" ${j} "* ]] && isignored=1
            done
        fi

        if ((isignored)); then
            { ((! upgrade)) && warn $"skipping target: %s" "${colorW}${i}${reset}"; } ||
                warn $"%s: ignoring package upgrade" "${colorW}${i}${reset}"
            error $"Unresolved dependency '%s'" "${colorW}${i}${reset}" "${E_INSTALL_DEPS_FAILED}"
        fi
    done
    for i in "${aurdepspkgs[@]}"; do
        # skip already checked dependencies
        [[ " ${aurpkgs[*]} " = *" ${i} "* ]] && continue
        [[ " ${rmaurpkgs[*]} " = *" ${i} "* ]] &&
            error $"Unresolved dependency '%s'" "${colorW}${i}${reset}" "${E_INSTALL_DEPS_FAILED}"

        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" ${i} "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            aurdepspkgsgrp=($(GetInfo Groups "${i}"))
            mapfile -tO "${#aurdepspkgsgrp[@]}" aurdepspkgsgrp < <(expac -Ql'\n' '%G' "${i}")
            for j in "${aurdepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " = *" ${j} "* ]] && isignored=1
            done
        fi

        if ((isignored)); then
            if ((! noconfirm)); then
                if ! Proceed y $"%s dependency is in IgnorePkg/IgnoreGroup. Install anyway?" "${i}"; then
                    warn $"skipping target: %s" "${colorW}${i}${reset}"
                    error $"Unresolved dependency '%s'" "${colorW}${i}${reset}" "${E_INSTALL_DEPS_FAILED}"
                fi
            else
                { ((upgrade)) && warn $"%s: ignoring package upgrade" "${colorW}${i}${reset}"; } ||
                    warn $"skipping target: %s" "${colorW}${i}${reset}"
                error $"Unresolved dependency '%s'" "${colorW}${i}${reset}" "${E_INSTALL_DEPS_FAILED}"
            fi
        fi
        deps+=("${i}")
    done
}

ProviderChecks() {
    local providersdeps providersdepsnover providers repodepspkgsprovided providerspkgs provided
    local nb providersnb
    # global repodepspkgs repoprovidersconflictingpkgs repodepsSver repodepsSrepo repodepsQver
    [[ "${repodepspkgs[*]}" ]] || return

    # filter directly provided deps
    mapfile -t noprovidersdeps < <(expac -S1 '%n' "${repodepspkgs[@]}")
    mapfile -t providersdeps < <(CommArr 'noprovidersdeps' 'repodepspkgs' '-13')

    # remove installed providers
    mapfile -t providersdeps < <("${pacmanbin}" -T -- "${providersdeps[@]}" | sort -u)

    for i in "${!providersdeps[@]}"; do
        # check versioning
        unset providersdepsname providersdepsver providersdepsSname providersdepsSver
        providersdepsname="${providersdeps[i]%%[><=]*}"
        providersdepsver="${providersdeps[i]##*[><=]}"
        mapfile -t providersdepsSname < <(expac -Ss '%n' "^${providersdepsname[i]}$")
        mapfile -t providersdepsSver < <(expac -Ss '%v' "^${providersdepsname[i]}$")

        case "${providersdeps[i]}" in
            *">"*|*"<"*|*"="*)
                for j in "${!providersdepsSname[@]}"; do
                    unset providersdepverdiff
                    providersdepsverdiff="$(vercmp "${providersdepsver}" "${providersdepsSver[j]}")"
                    # found in repo but version not correct
                    case "${providersdeps[i]}" in
                        *">="*) ((providersdepsverdiff >= 0)) && continue;;
                        *"<="*) ((providersdepsverdiff <= 0)) && continue;;
                        *">"*)  ((providersdepsverdiff > 0))  && continue;;
                        *"<"*)  ((providersdepsverdiff < 0))  && continue;;
                        *"="*)  ((providersdepsverdiff == 0)) && continue;;
                    esac
                    providersdepsnover+=("${providersdepsSname[j]}")
                done
            ;;
        esac

        # remove versioning
        providersdeps[i]="${providersdeps[i]%%[><=]*}"

        # list providers
        mapfile -t providers < <(expac -Ss '%n' "^${providersdeps[i]}$" | sort -u)

        # filter out non matching versioned providers
        [[ "${providersdepsnover[*]}" ]] && mapfile -t providers < <(CommArr 'providers'{'depsnover',} '-12')

        # skip if provided in dependency chain
        repodepspkgsprovided=0
        for j in "${!providers[@]}"; do
            [[ " ${repodepspkgs[*]} " != *" ${providers[j]} "* ]] || repodepspkgsprovided=1
        done
        ((repodepspkgsprovided)) && continue

        # skip if already provided
        if [[ "${providerspkgs[*]}" ]]; then
            providerspkgs=($(printf '%s|' "${providerspkgs[@]}"))
            providerspkgs=("${providerspkgs[@]%|}")
            mapfile -tO "${#provided[@]}" provided < <(expac -Ssl'\n' '%S' "^(${providerspkgs[*]})$")
            [[ " ${provided[*]} " != *" ${providersdeps[i]} "* ]] || continue
        fi

        if ((! noconfirm && "${#providers[*]}" > 1)); then
            info $"%sThere are %s providers available for %s:%s" "${colorW}" "${#providers[@]}" \
                "${providersdeps[i]}" "${reset}"
            expac -S1 '   %!) %n (%r) ' "${providers[@]}"
            nb='-1'
            providersnb="$(("${#providers[@]}" - 1))" # count from 0
            while ((nb < 0 || nb >= "${#providers}")); do
                printf '\n%s ' $"Enter a number (default=0):"
                case "${TERM}" in
                    dumb)
                    read -r nb
                    ;;
                    *)
                    read -r -n "${#providersnb}" nb
                    printf '\n'
                    ;;
                esac

                case "${nb}" in
                    [0-9]|[0-9][0-9]) if ((nb < 0 || nb >= "${#providers[@]}")); then
                            printf '\n'
                            fail $"invalid value: %s is not between 0 and %s" "${nb}" "${providersnb}" && ((--i))
                        else
                            break
                        fi;;
                    '') nb=0;;
                    *) fail $"invalid number: %s" "${nb}";;
                esac
            done
        else
            nb=0
        fi
        providerspkgs+=("${providers[nb]}")
    done

    # add selected providers to repo deps
    repodepspkgs+=("${providerspkgs[@]}")

    # store for installation
    repoprovidersconflictingpkgs+=("${providerspkgs[@]}")

    FindDepsRepoProvider "${providerspkgs[@]}"

    # get binary packages info
    if [[ "${repodepspkgs[*]}" ]]; then
        mapfile -t repodepspkgs < <(expac -S1 '%n' "${repodepspkgs[@]}" | sort -u)
        mapfile -t repodepsSver < <(expac -S1 '%v' "${repodepspkgs[@]}")
        mapfile -t repodepsQver < <(expac -Q '%v' "${repodepspkgs[@]}")
        mapfile -t repodepsSrepo < <(expac -S1 '%r/%n' "${repodepspkgs[@]}")
    fi
}

ConflictChecks() {
    local allQprovides allQconflicts Aprovides Aconflicts aurconflicts aurAconflicts Qrequires i j
    local k l repodepsprovides repodepsconflicts checkedrepodepsconflicts repodepsconflictsname
    local repodepsconflictsver localver repoconflictingpkgs
    # global deps depsAname aurdepspkgs aurconflictingpkgs aurconflictingpkgskeep aurconflictingpkgsrm
    # global depsQver repodepspkgs repoconflictingpkgskeep repoconflictingpkgsrm repoprovidersconflictingpkgs
    printf '%s\n' $"looking for inter-conflicts..."

    mapfile -t allQprovides < <(expac -Q '%n')
    mapfile -tO "${#allQprovides[@]}" allQprovides < <(expac -Ql'\n' '%S') # no versioning
    mapfile -t allQconflicts < <(expac -Ql'\n' '%C')

    # AUR conflicts
    Aprovides=("${depsAname[@]}")
    Aprovides+=($(GetInfo Provides))
    Aconflicts=($(GetInfo Conflicts))
    # remove AUR versioning
    Aprovides=("${Aprovides[@]%%[><=]*}")
    Aconflicts=("${Aconflicts[@]%%[><=]*}")
    mapfile -t aurconflicts < <(CommArr 'Aprovides' 'allQconflicts' '-12')
    mapfile -tO "${#aurconflicts[@]}" aurconflicts < <(CommArr 'Aconflicts' 'allQprovides' '-12')
    aurconflicts=($(printf '%s\n' "${aurconflicts[@]}" | sort -u))

    for i in "${aurconflicts[@]}"; do
        unset aurAconflicts
        [[ " ${depsAname[*]} " = *" ${i} "* ]] && aurAconflicts=("${i}")
        for j in "${depsAname[@]}"; do
            [[ " $(GetInfo Conflicts "${j}") " = *" ${i} "* ]] && aurAconflicts+=("${j}")
        done

        for j in "${aurAconflicts[@]}"; do
            unset Aprovides
            read -rd' ' k < <(expac -Qs '%n %P' "^${i}$")
            ((! installpkg)) && [[ " ${aurdepspkgs[*]} " != *" ${j} "* ]] && continue # download only
            [[ "${j}" = "${k}" || ! "${k}" ]] && continue # skip if reinstalling or if no conflict exists

            Aprovides=("${j}")
            if ((! noconfirm)) && [[ " ${aurconflictingpkgs[*]} " != *" ${k} "* ]]; then
                if ! Proceed n $"%s and %s are in conflict (%s). Remove %s?" "${j}" "${k}" "${i}" "${k}"; then
                    aurconflictingpkgs+=("${j}" "${k}")
                    aurconflictingpkgskeep+=("${j}")
                    aurconflictingpkgsrm+=("${k}")
                    for l in "${!depsAname[@]}"; do
                        [[ " ${depsAname[l]} " != *"${k}"* ]] ||
                            read -rd' ' depsQver[l] < <(expac -Qs '%v' "^${k}$")
                    done
                    Aprovides+=($(GetInfo Provides "${j}"))
                    # remove AUR versioning
                    Aprovides=("${Aprovides[@]%%[><=]*}")
                    [[ " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " = *" ${k} "* ]] || CheckRequires "${k}"
                    break
                else
                    fail $"unresolvable package conflicts detected"
                    fail $"failed to prepare transaction (conflicting dependencies)"
                    if ((upgrade)); then
                        mapfile -t Qrequires < <(expac -Ql'\n' '%N' "${i}")
                        error $"%s and %s are in conflict (required by %s)" "${j}" "${k}" "${Qrequires[*]}" \
                            "${E_INSTALL_DEPS_FAILED}"
                    else
                        error $"%s and %s are in conflict" "${j}" "${k}" "${E_INSTALL_DEPS_FAILED}"
                    fi
                fi
            fi
            Aprovides+=($(GetInfo Provides "${j}"))
            # remove AUR versioning
            Aprovides=("${Aprovides[@]%%[><=]*}")
            [[ " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " = *" ${k} "* ]] || CheckRequires "${k}"
        done
    done

    NothingToDo "${deps[@]}"

    # repo conflicts
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepsprovides=("${repodepspkgs[@]}")
        # no versioning
        mapfile -tO "${#repodepsprovides[@]}" repodepsprovides < <(expac -S1l'\n' '%S' "${repodepspkgs[@]}")
        mapfile -t repodepsconflicts < <(expac -S1l'\n' '%H' "${repodepspkgs[@]}")

        # versioning check
        unset checkedrepodepsconflicts
        for i in "${!repodepsconflicts[@]}"; do
            unset repodepsconflictsname repodepsconflictsver localver
            repodepsconflictsname="${repodepsconflicts[i]%%[><=]*}"
            repodepsconflictsver="${repodepsconflicts[i]##*[><=]}"
            localver="$(expac -Q '%v' "${repodepsconflictsname}")"
            repodepsconflictsverdiff="$(vercmp "${repodepsconflictsver}" "${localver}")"

            if [[ "${localver}" ]]; then
                case "${repodepsconflicts[i]}" in
                    *">="*) ((repodepsconflictsverdiff >= 0)) && continue;;
                    *"<="*) ((repodepsconflictsverdiff <= 0)) && continue;;
                    *">"*)  ((repodepsconflictsverdiff > 0))  && continue;;
                    *"<"*)  ((repodepsconflictsverdiff < 0))  && continue;;
                    *"="*)  ((repodepsconflictsverdiff == 0)) && continue;;
                esac
                checkedrepodepsconflicts+=("${repodepsconflictsname}")
            fi
        done

        mapfile -tO "${#repoconflicts[@]}" repoconflicts < <(CommArr 'repodepsprovides' 'allQconflicts' '-12')
        mapfile -tO "${#repoconflicts[@]}" repoconflicts < \
            <(CommArr 'checkedrepodepsconflicts' 'allQprovides' '-12')
        repoconflicts=($(printf '%s\n' "${repoconflicts[@]}" | sort -u))
    fi

    for i in "${repoconflicts[@]}"; do
        unset Qprovides
        read -rd' ' j < <(expac -Ss '%n %C %S' "^${i}$")
	    read -rd' ' k < <(expac -Qs '%n %C %S' "^${i}$")
        [[ "${j}" = "${k}" || ! "${k}" ]] && continue # skip when no conflict with repopkgs
        if ((! noconfirm)) && [[ " ${repoconflictingpkgs[*]} " != *" ${k} "* ]]; then
            if ! Proceed n $"%s and %s are in conflict (%s). Remove %s?" "${j}" "${k}" "${i}" "${k}"; then
                repoconflictingpkgs+=("${j}" "${k}")
                repoconflictingpkgskeep+=("${j}")
                repoconflictingpkgsrm+=("${k}")
                repoprovidersconflictingpkgs+=("${j}")
                mapfile -t Qprovides < <(expac -Ssl'\n' '%S' "^${k}$")
                [[ " ${Qprovides[*]} ${repoconflictingpkgsrm[*]} " = *" ${k} "* ]] || CheckRequires "${k}"
                break
            else
                fail $"unresolvable package conflicts detected"
                fail $"failed to prepare transaction (conflicting dependencies)"
                if ((upgrade)); then
                    mapfile -t Qrequires < <(expac -Ql'\n' '%N' "${i}")
                    error $"%s and %s are in conflict (required by %s)" "${j}" "${k}" "${Qrequires[*]}" \
                        "${E_INSTALL_DEPS_FAILED}"
                else
                    error $"%s and %s are in conflict" "${j}" "${k}" "${E_INSTALL_DEPS_FAILED}"
                fi
            fi
        fi
        mapfile -t Qprovides < <(expac -Ssl'\n' '%S' "^${k}$")
        [[ " ${Qprovides[*]} " = *" ${k} "* ]] || CheckRequires "${k}"
    done
}

ReinstallChecks() {
    local i depsAtmp
    # global aurpkgs aurdepspkgs deps aurconflictingpkgs depsAname depsQver depsAver depsAood depsAmain
    depsAtmp=("${depsAname[@]}")
    for i in "${!depsAtmp[@]}"; do
        [[ " ${aurpkgs[*]} " = *" ${depsAname[i]} "* &&
            " ${aurconflictingpkgs[*]} " != *" ${depsAname[i]} "* ]] || continue
        [[ "${depsQver[i]}" != ?('%') && "$(vercmp "${depsAver[i]}" "${depsQver[i]}")" -le 0 ]] || continue
        ((installpkg)) || [[ " ${aurdepspkgs[*]} " = *" ${depsAname[i]} "* ]] || continue
        if [[ "${depsAname[i]}" = *${vcs} ]]; then
            warn $"%s latest revision -- fetching" "${colorW}${depsAname[i]}${reset}"
        else
            if ((! needed)); then
                warn $"%s-%s is up to date -- reinstalling" "${colorW}${depsAname[i]}" "${depsQver[i]}${reset}"
            else
                warn $"%s-%s is up to date -- skipping" "${colorW}${depsAname[i]}" "${depsQver[i]}${reset}"
                mapfile -t deps < <(printf ' %s \n' "${deps[@]}")
                deps=($(printf '%s\n' "${deps[@]// ${depsAname[i]} /}"))
                unset 'depsAname[i]' 'depsQver[i]' 'depsAver[i]' 'depsAood[i]' 'depsAmain[i]'
            fi
        fi
    done
    ((needed)) && depsAname=("${depsAname[@]}") && depsQver=("${depsQver[@]}") &&
        depsAver=("${depsAver[@]}") && depsAood=("${depsAood[@]}") && depsAmain=("${depsAmain[@]}")
    NothingToDo "${deps[@]}"
}

OutOfDateChecks() {
    local i
    # global depsAname depsAver depsAood
    for i in "${!depsAname[@]}"; do
        (("${depsAood[i]}" > 0)) &&
            warn $"%s-%s has been flagged %sout of date%s on %s" "${colorW}${depsAname[i]}" "${depsAver[i]}${reset}" "${colorR}" "${reset}" "${colorY}$(printf '%(%c)T' "${depsAood[i]}")${reset}"
    done
}

OrphanChecks() {
    local i
    # global depsAname depsAver depsAmain
    for i in "${!depsAname[@]}"; do
        [[ "${depsAmain[i]}" = 'null' || ! "${depsAmain[i]}" ]] &&
            warn $"%s-%s is %sorphaned%s in AUR" "${colorW}${depsAname[i]}" "${depsAver[i]}${reset}" "${colorR}" "${reset}"
    done
}

Prompt() {
    local i binaryksize sumk summ builtpkg cachedpkgs stroldver strnewver strsize depsver
    local repodepspkgsver strrepodlsize strrepoinsize strsumk strsumm lreposizelabel lreposize
    # global repodepspkgs repodepsSver depsAname depsAver depsArepo depsAcached lname lver lsize
    # global deps depsQver repodepspkgs repodepsSrepo repodepsQver repodepsSver
    # compute binary size
    if [[ "${repodepspkgs[*]}" ]]; then
        mapfile -t binaryksize < <(expac -S1 '%k' "${repodepspkgs[@]}")
        mapfile -t binarymsize < <(expac -S1 '%m' "${repodepspkgs[@]}")
        sumk=0
        summ=0
        for i in "${!repodepspkgs[@]}"; do
            GetBuiltPkg "${repodepspkgs[i]}-${repodepsSver[i]}" "$(pacman-conf CacheDir)"
            [[ "${builtpkg}" ]] && binaryksize[i]=0
            sumk="$((sumk + "${binaryksize[i]}"))"
            summ="$((summ + "${binarymsize[i]}"))"
        done
        sumk="$((sumk / 1048576)).$((sumk / 1024 % 1024 * 100 / 1024))"
        summ="$((summ / 1048576)).$((summ / 1024 % 1024 * 100 / 1024))"
    fi

    # cached packages check
    for i in "${!depsAname[@]}"; do
        [[ ! "${PKGDEST}" ]] || ((rebuild)) && break
        GetBuiltPkg "${depsAname[i]}-${depsAver[i]}" "${PKGDEST}"
        [[ "${builtpkg}" ]] && cachedpkgs+=("${depsAname[i]}") depsAcached[i]='('$"cached"')' || depsAcached[i]=''
        unset builtpkg
    done

    if [[ "$(pacman-conf VerbosePkgLists)" ]]; then
        straurname=$"AUR Packages  (${#deps[@]})"; strreponame=$"Repo Packages (${#repodepspkgs[@]})"
        stroldver=$"Old Version"; strnewver=$"New Version"; strsize=$"Download Size"
        depsArepo=("${depsAname[@]/#/aur/}")
        lname="$(GetLength "${depsArepo[@]}" "${repodepsSrepo[@]}" "${straurname}" "${strreponame}")"
        lver="$(GetLength "${depsQver[@]}" "${depsAver[@]}" "${repodepsQver[@]}" "${repodepsSver[@]}" "${stroldver}" "${strnewver}")"
        lsize="$(GetLength "${strsize}")"

        # local version column cleanup
        for i in "${!deps[@]}"; do
            [[ "${depsQver[i]}" != '%' ]] || unset 'depsQver[i]'
        done
        # show detailed output
        printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s${reset}\n\n" \
            "${straurname}" "${stroldver}" "${strnewver}"
        for i in "${!deps[@]}"; do
            printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" \
                "${depsArepo[i]}" "${depsQver[i]}" "${depsAver[i]}" "${depsAcached[i]}";
        done

        if [[ "${repodepspkgs[*]}" ]]; then
            for i in "${!repodepspkgs[@]}"; do
                binarysize[i]="$((binaryksize[i] / 1048576)).$((binaryksize[i] / 1024 % 1024 * 100 / 1024))"
            done
            printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s  %s${reset}\n\n" \
                "${strreponame}" "${stroldver}" "${strnewver}" "${strsize}"
            for i in "${!repodepspkgs[@]}"; do
                printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" \
                    "${repodepsSrepo[i]}" "${repodepsQver[i]}" "${repodepsSver[i]}" $"${binarysize[i]} MiB"
            done
        fi
    else
        # show version
        for i in "${!deps[@]}"; do
            depsver="${depsver-}${depsAname[i]}-${depsAver[i]}  "
        done
        for i in "${!repodepspkgs[@]}"; do
            repodepspkgsver="${repodepspkgsver-}${repodepspkgs[i]}-${repodepsSver[i]}  "
        done
        printf "\n${colorW}%-16s${reset} %s\n" $"AUR Packages  (${#deps[@]})" "${depsver}"
        [[ "${repodepspkgs[*]}" ]] &&
            printf "${colorW}%-16s${reset} %s\n" $"Repo Packages (${#repodepspkgs[@]})" "${repodepspkgsver}"
    fi

    if [[ "${repodepspkgs[*]}" ]]; then
        strrepodlsize=$"Repo Download Size:"; strrepoinsize=$"Repo Installed Size:"; strsumk="${sumk}"$"MiB"
        strsumm="${summ}"$"MiB" lreposizelabel="$(GetLength "${strrepodlsize}" "${strrepoinsize}")"
        lreposize="$(GetLength "${strsumk}" "${strsumm}")"
        printf "\n${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "${strrepodlsize}" "${strsumk}"
        printf "${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "${strrepoinsize}" "${strsumm}"
    fi

    printf '\n'
    if ((installpkg)); then
        Proceed y $"Proceed with installation?" || exit "${E_FAIL}"
    else
        Proceed y $"Proceed with download?" || exit "${E_FAIL}"
    fi
}

DownloadPkgs() {
    local i
    # global basepkgs
    info $"%sRetrieving package(s)...%s" "${colorW}" "${reset}"
    GetPkgbase "$@"

    # no results check
    [[ "${basepkgs[*]}" ]] || error $"no results found" "${E_INSTALL_DEPS_FAILED}"

    # reset
    for i in "${basepkgs[@]}"; do
        if [[ -d "${clonedir}/${i}" ]]; then
            git -C "${clonedir}/${i}" reset --hard HEAD -q # updated pkgver of vcs packages block pull
            [[ "${displaybuildfiles}" = 'diff' ]] &&
                git -C "${clonedir}/${i}" rev-parse HEAD >"${clonedir}/${i}/.git/HEAD.prev"
        fi
    done

    # clone
    auracle -C "${clonedir}" clone "$@" >/dev/null ||
        error $"failed to retrieve packages" "${E_INSTALL_DEPS_FAILED}"
}

EditPkgs() {
    local viewed=0 i j erreditpkg prev
    # global cachedpkgs installscripts editor
    ((noedit)) && return
    for i in "$@"; do
        [[ " ${cachedpkgs[*]} " = *" ${i} "* ]] && continue
        GetInstallScripts "${i}"
        if ((! pace)); then
            if [[ "${displaybuildfiles}" = 'diff' && -e "${clonedir}/${i}/.git/HEAD.prev" ]]; then
                prev="$(<"${clonedir}/${i}/.git/HEAD.prev")"
                # show diff
                if git -C "${clonedir}/${i}" diff --quiet --no-ext-diff "${prev}" -- . ':!\.SRCINFO'; then
                    warn $"%s build files are up-to-date -- skipping" "${colorW}${i}${reset}"
                else
                    if Proceed y $"View %s build files diff?" "${i}"; then
                        git -C "${clonedir}/${i}" diff --no-ext-diff "${prev}" -- . ':!\.SRCINFO' ||
                            erreditpkg+=("${i}")
                        info $"%s build files diff viewed" "${colorW}${i}${reset}"; viewed=1
                    fi
                fi
            elif [[ "${displaybuildfiles}" != 'none' ]]; then
                # show pkgbuild
                if Proceed y $"View %s PKGBUILD?" "${i}"; then
                    if [[ -e "${clonedir}/${i}/PKGBUILD" ]]; then
                        "${editor}" "${clonedir}/${i}/PKGBUILD" &&
                            info $"%s PKGBUILD viewed" "${colorW}${i}${reset}" || erreditpkg+=("${i}")
                    else
                        error $"Could not open %s PKGBUILD" "${colorW}${i}${reset}" "${E_MISSING_FILE}"
                    fi
                fi
                # show install script
                if [[ "${installscripts[*]}" ]]; then
                    for j in "${installscripts[@]}"; do
                        if Proceed y $"View %s script?" "${j}"; then
                            if [[ -e "${clonedir}/${i}/${j}" ]]; then
                                "${editor}" "${clonedir}/${i}/${j}" &&
                                    info $"%s script viewed" "${colorW}${j}${reset}" ||
                                    erreditpkg+=("${i}")
                            else
                                error $"Could not open %s script" "${colorW}${j}${reset}" "${E_MISSING_FILE}"
                            fi
                        fi
                    done
                fi
            fi
        else
            # show pkgbuild and install script
            if [[ -e "${clonedir}/${i}/PKGBUILD" ]]; then
                "${editor}" "${clonedir}/${i}/PKGBUILD" &&
                    info $"%s PKGBUILD viewed" "${colorW}${i}${reset}" || erreditpkg+=("${i}")
            else
                error $"Could not open %s PKGBUILD" "${colorW}${i}${reset}" "${E_MISSING_FILE}"
            fi
            if [[ "${installscripts[*]}" ]]; then
                for j in "${installscripts[@]}"; do
                    if [[ -e "${clonedir}/${i}/${j}" ]]; then
                        "${editor}" "${clonedir}/${i}/${j}" &&
                            info $"%s script viewed" "${colorW}${j}${reset}" || erreditpkg+=("${i}")
                    else
                        error $"Could not open %s script" "${colorW}${j}${reset}" "${E_MISSING_FILE}"
                    fi
                done
            fi
        fi
    done

    if [[ "${erreditpkg[*]}" ]]; then
        for i in "${erreditpkg[@]}"; do
            fail $"%s errored on exit" "${colorW}${i}${reset}"
        done
        exit "${E_FAIL}"
    fi

    if [[ "${displaybuildfiles}" = diff ]] && ((viewed)); then
        if ((installpkg)); then
            Proceed y $"Proceed with installation?" || exit
        else
            Proceed y $"Proceed with download?" || exit
        fi
    fi
}

MakePkgs() {
    local i j k oldorphanpkgs neworphanpkgs orphanpkgs oldoptionalpkgs newoptionalpkgs optionalpkgs
    local errinstall pkgsdepslist vcsclients vcschecked aurpkgsAver aurpkgsQver built{,deps}pkgs
    local basepkgsupdate checkpkgsdepslist isaurdeps makedeps {basepkgs,pkgsdeps}rev
    # global deps basepkgs sudoloop pkgsbase pkgsdeps aurpkgs aurdepspkgs builtpkg errmakepkg
    # global repoprovidersconflictingpkgs

    # download
    DownloadPkgs "${deps[@]}"
    EditPkgs "${basepkgs[@]}"

    # current orphan and optional packages
    mapfile -t oldorphanpkgs < <("${pacmanbin}" -Qdtq)
    mapfile -t oldoptionalpkgs < <("${pacmanbin}" -Qdttq)
    mapfile -t oldoptionalpkgs < <(CommArr 'oldorphanpkgs' 'oldoptionalpkgs' '-13')

    # initialize sudo
    if sudo -n "${pacmanbin}" -V &>/dev/null || sudo -v; then
        [[ "${sudoloop}" = true ]] && SudoV &
    fi

    # split packages support
    for i in "${!pkgsbase[@]}"; do
        for j in "${!deps[@]}"; do
            if [[ "${pkgsbase[i]}" = "${pkgsbase[j]}" && "${pkgsdeps[*]}" != *",${deps[j]}"?(,*) ]]; then
                pkgsdeps[i]+=",${deps[j]}"
            fi
        done
    done
    pkgsdeps=("${pkgsdeps[@]#,}") # remove empty array indices and leading ','

    # reverse deps order
    for i in "${!basepkgs[@]}"; do
        basepkgsrev[i]="${basepkgs[-i-1]}"
    done
    basepkgs=("${basepkgsrev[@]}")
    for i in "${!pkgsdeps[@]}"; do
        pkgsdepsrev[i]="${pkgsdeps[-i-1]}"
    done
    pkgsdeps=("${pkgsdepsrev[@]}")

    # integrity check
    for i in "${!basepkgs[@]}"; do
        IFS=',' read -ra pkgsdepslist <<< "${pkgsdeps[i]}" # get split packages list

        # cache check
        unset builtpkg
        if [[ "${basepkgs[i]}" != *${vcs} ]]; then
            for j in "${pkgsdepslist[@]}"; do
                [[ "${PKGDEST}" ]] && ((! rebuild)) &&
                    GetBuiltPkg "${j}-$(GetInfo Version "${j}")" "${PKGDEST}"
            done
        fi

        # install vcs clients (checking pkgbase extension only does not take fetching specific
        # commit into account)
        unset vcsclients
        makedeps=($(GetInfo MakeDepends "${basepkgs[i]}"))
        for k in git subversion mercurial bzr cvs darcsl; do
            [[ " ${makedeps[*]} " = *" ${k} "* ]] && vcsclients+=("${k}")
        done
        unset makedeps
        for j in "${vcsclients[@]}"; do
            if [[ " ${vcschecked[*]} " != *" ${j} "* ]]; then
                expac -Qs '' "^${j}$" || sudo "${pacmanbin}" -S --asdeps --noconfirm -- "${j}"
                vcschecked+=("${j}")
            fi
        done

        if [[ ! "${builtpkg-}" ]] || ((rebuild)); then
            cd "${clonedir:?}/${basepkgs[i]}" || exit "${E_MISSING_FILE}"
            info $"Checking %s integrity..." "${colorW}${pkgsdeps[i]}${reset}"
            if [[ "${silent}" = true ]]; then
                makepkg -f --verifysource "${makeopts[@]}" &>/dev/null || errmakepkg+=("${pkgsdeps[i]}")
            else
                makepkg -f --verifysource "${makeopts[@]}"  >/dev/null || errmakepkg+=("${pkgsdeps[i]}")
            fi
            # extraction, prepare and pkgver update
            info $"Preparing %s..." "${colorW}${pkgsdeps[i]}${reset}"
            if [[ "${silent}" = true ]]; then
                makepkg -od --skipinteg "${makeopts[@]}" &>/dev/null || errmakepkg+=("${pkgsdeps[i]}")
            else
                makepkg -od --skipinteg "${makeopts[@]}" || errmakepkg+=("${pkgsdeps[i]}")
            fi
        fi
    done
    if [[ "${errmakepkg[*]}" || "${errinstall[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            fail $"failed to verify integrity or prepare %s package" "${colorW}${i}${reset}"
        done
        # remove sudo lock
        rm -f "${tmpdir:?}/pacaur.sudov.lck"
        exit "${E_FAIL}"
    fi

    # check database lock
    [[ ! -e "/var/lib/pacman/db.lck" ]] || error $"db.lck exists in /var/lib/pacman" "${E_FAIL}"

    # set build lock
    [[ ! -e "${tmpdir}/pacaur.build.lck" ]] || error $"pacaur.build.lck exists in %s" "${tmpdir}" "${E_FAIL}"
    : >"${tmpdir}/pacaur.build.lck"

    # install provider packages and repo conflicting packages that makepkg --noconfirm cannot handle
    if [[ "${repoprovidersconflictingpkgs[*]}" ]]; then
        info $"Installing %s dependencies..." "${colorW}${repoprovidersconflictingpkgs[*]}${reset}"
        sudo "${pacmanbin}" -S "${repoprovidersconflictingpkgs[@]}" --ask 36 --asdeps --noconfirm
    fi

    # main
    for i in "${!basepkgs[@]}"; do
        IFS=',' read -ra pkgsdepslist <<< "${pkgsdeps[i]}" # get split packages list

        cd "${clonedir}/${basepkgs[i]}" || exit "${E_MISSING_FILE}"
        # retrieve updated version
        mapfile -td'-' k < <(makepkg --packagelist); aurpkgsAver="${k[-3]}-${k[-2]}"; unset k
        # build devel if necessary only (supported protocols only)
        if [[ "${basepkgs[i]}" = *${vcs} ]]; then
            # check split packages update
            unset basepkgsupdate checkpkgsdepslist
            for j in "${pkgsdepslist[@]}"; do
                read -rd' ' < <(expac -Qs '%v' "^${j}$") aurpkgsQver
                if ((needed && ! rebuild)) &&
                    [[ "${aurpkgsQver}" && "$(vercmp "${aurpkgsQver}" "${aurpkgsAver}")" -ge 0 ]]; then
                    warn $"%s is up-to-date -- skipping" "${colorW}${j}${reset}" && continue
                else
                    basepkgsupdate='true'; checkpkgsdepslist+=("${j}")
                fi
            done
            if [[ "${basepkgsupdate}" ]]; then
                pkgsdepslist=("${checkpkgsdepslist[@]}")
            else
                continue
            fi
        fi

        # check package cache
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            [[ "${PKGDEST}" ]] && ((! rebuild)) && GetBuiltPkg "${j}-${aurpkgsAver}" "${PKGDEST}"
            if [[ "${builtpkg}" ]]; then
                if [[ " ${aurdepspkgs[*]} " = *" ${j} "* ]] || ((installpkg)); then
                    info $"Installing %s cached package..." "${colorW}${j}${reset}"
                    sudo "${pacmanbin}" -U --ask 36 "${pacopts[@]/--quiet}" --noconfirm -- "${builtpkg}"
                    [[ " ${aurpkgs[*]} " = *" ${j} "* ]] ||
                        sudo "${pacmanbin}" -D "${j}" --asdeps "${pacopts[@]}" &>/dev/null
                else
                    warn $"Package %s already available in cache" "${colorW}${j}${reset}"
                fi
                pkgsdeps=("${pkgsdeps[@]/#${j},}"); pkgsdeps=("${pkgsdeps[@]/%,${j}}")
                pkgsdeps=("${pkgsdeps[@]//,${j},/,}")
                for k in "${!pkgsdeps[@]}"; do
                    [[ "${pkgsdeps[k]}" = "${j}" ]] && pkgsdeps[k]='%'
                done
                continue
            fi
        done
        [[ "${pkgsdeps[i]}" != '%' ]] || continue

        # build
        info $"Building %s package(s)..." "${colorW}${pkgsdeps[i]}${reset}"

        # install then remove binary deps
        makeopts=("${makeopts[@]/-r/}")

        if ((! installpkg)); then
            isaurdeps=0
            for j in "${pkgsdepslist[@]}"; do
                [[ " ${aurdepspkgs[*]} " = *" ${j} "* ]] && isaurdeps=1
            done
            ((isaurdeps)) && makeopts+=('-r')
        fi

        # skip install for packages that fail to build
        if [[ "${silent}" = true ]]; then
            makepkg -sefc "${makeopts[@]}" --noconfirm &>/dev/null ||
                { errmakepkgs+=("${pkgsdeps[i]}"); continue; }
        else
            makepkg -sefc "${makeopts[@]}" --noconfirm || { errmakepkgs+=("${pkgsdeps[i]}"); continue; }
        fi

        # retrieve filename
        unset builtpkgs builtdepspkgs
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            if [[ "${PKGDEST}" ]]; then
                GetBuiltPkg "${j}-${aurpkgsAver}" "${PKGDEST}"
            else
                GetBuiltPkg "${j}-${aurpkgsAver}" "${clonedir:?}/${basepkgs[i]}"
            fi
            [[ " ${aurdepspkgs[*]} " = *" ${j} "* ]] && builtdepspkgs+=("${builtpkg}") ||
                builtpkgs+=("${builtpkg}")
        done

        # install
        if ((installpkg)) || [[ ! "${builtpkgs[*]}" ]]; then
            info $"Installing %s package(s)..." "${colorW}${pkgsdeps[i]}${reset}"
            sudo "${pacmanbin}" -U "${builtdepspkgs[@]}" "${builtpkgs[@]}" \
                --ask 36 "${pacopts[@]/--quiet}" --noconfirm
        fi

        # set dep status
        if ((installpkg)); then
            for j in "${pkgsdepslist[@]}"; do
                [[ " ${aurpkgs[*]} " = *" ${j} "* ]] || sudo "${pacmanbin}" -D "${j}" --asdeps &>/dev/null
                ((asdeps)) && sudo "${pacmanbin}" -D "${j}" --asdeps &>/dev/null
                ((asexplicit)) && sudo "${pacmanbin}" -D "${j}" --asexplicit &>/dev/null
            done
        fi
    done

    # remove AUR deps
    if ((! installpkg)); then
        [[ "${aurdepspkgs[*]}" ]] && mapfile -t aurdepspkgs < <(expac -Q '%n' "${aurdepspkgs[@]}")
        [[ "${aurdepspkgs[*]}" ]] && info $"Removing installed AUR dependencies..." &&
            sudo "${pacmanbin}" -Rsn "${aurdepspkgs[@]}" --noconfirm
        # re-add removed conflicting packages
        [[ "${aurconflictingpkgsrm[*]}" ]] &&
            sudo "${pacmanbin}" -S "${aurconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
        [[ "${repoconflictingpkgsrm[*]}" ]] &&
            sudo "${pacmanbin}" -S "${repoconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
    fi

    # remove locks
    rm "${tmpdir:?}/pacaur.build.lck"
    rm -f "${tmpdir:?}/pacaur.sudov.lck"

    # new orphan and optional packages check
    mapfile -t orphanpkgs < <("${pacmanbin}" -Qdtq)
    mapfile -t neworphanpkgs < <(CommArr 'oldorphanpkgs' 'orphanpkgs' '-13')
    for i in "${neworphanpkgs[@]}"; do
        warn $"%s is now an %sorphan%s package" "${colorW}${i}${reset}" "${colorY}" "${reset}"
    done
    mapfile -t optionalpkgs < <("${pacmanbin}" -Qdttq)
    mapfile -t optionalpkgs < <(CommArr 'orphanpkgs' 'optionalpkgs' '-13')
    mapfile -t newoptionalpkgs < <(CommArr 'oldoptionalpkgs' 'optionalpkgs' '-13')
    for i in "${newoptionalpkgs[@]}"; do
        warn $"%s is now an %soptional%s package" "${colorW}${i}${reset}" "${colorY}" "${reset}"
    done

    # makepkg and install failure check
    if [[ "${errmakepkg[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            fail $"failed to build %s package(s)" "${colorW}${i}${reset}"
        done
        exit "${E_PACKAGE_FAILED}"
    fi
    [[ "${errinstall[*]}" ]] && exit "${E_INSTALL_FAILED}"
}

CleanCache() {
    local i cachepkgs foreignpkgs foreignpkgsbase
    mapfile -t cachedir < <(pacman-conf CacheDir)
    [[ "${cachedir[*]}" ]] && cachedir=("${cachedir[@]%/}") && PKGDEST="${PKGDEST%/}"
    if [[ "${PKGDEST}" && " ${cachedir[*]} " != *" ${PKGDEST} "* ]]; then
        ((ccount == 1)) && printf '\n%s\n %s\n' $"Packages to keep:" $"All locally installed packages"
        printf '\n%s %s\n' $"AUR cache directory:" "${PKGDEST}"
        if ((ccount == 1)); then
            if Proceed y $"Do you want to remove all other packages from AUR cache?"; then
                printf '%s\n' $"removing old packages from cache..."
                cachepkgs=("${PKGDEST:?}"/*); cachepkgs=("${cachepkgs[@]##*/}")
                for i in "${cachepkgs[@]%-*}"; do
                    [[ "${i}" != "$(expac -Q '%n-%v' "${i%-*-*}")" ]] && rm "${PKGDEST:?}/${i}"-*
                done
            fi
        else
            Proceed n $"Do you want to remove ALL files from AUR cache?" ||
                printf '%s\n' $"removing all files from AUR cache..." &&
                rm "${PKGDEST:?}"/* &>/dev/null
        fi
    fi

    if [[ -d "${SRCDEST}" ]]; then
        ((ccount == 1)) &&
            printf '\n%s\n %s\n' $"Sources to keep:" $"All development packages sources"
        printf '\n%s %s\n' $"AUR source cache directory:" "${SRCDEST}"
        if ((ccount == 1)); then
            Proceed y $"Do you want to remove all non development files from AUR source cache?" &&
                printf '%s\n' $"removing non development files from source cache..." &&
                rm -f "${SRCDEST:?}"/* &>/dev/null
        else
            Proceed n $"Do you want to remove ALL files from AUR source cache?" ||
                printf '%s\n' $"removing all files from AUR source cache..." &&
                rm -rf "${SRCDEST:?}"/*
        fi
    fi
    if [[ -d "${clonedir}" ]]; then
        if ((ccount == 1)); then
            if [[ ! "${pkgs[*]}" ]]; then
                printf '\n%s\n %s\n' $"Clones to keep:" $"All locally installed clones"
            else
                printf '\n%s\n %s\n' $"Clones to keep:" $"All other locally installed clones"
            fi
        fi
        printf '\n%s %s\n' $"AUR clone directory:" "${clonedir}"
        if ((ccount == 1)); then
            mapfile -t foreignpkgs < <("${pacmanbin}" -Qmq)
            mapfile -t foreignpkgsbase < <(expac -Q '%e' "${foreignpkgs[@]}")
            # get target
            if [[ "${pkgs[*]}" ]]; then
                mapfile -t pkgsbase < <(expac -Q '%e' "${pkgs[@]}")
                mapfile -t aurpkgsbase < <(CommArr 'pkgsbase' 'foreignpkgsbase' '-12')
                if Proceed y $"Do you want to remove %s clones from AUR clone directory?" \
                    "${aurpkgsbase[*]}"; then
                    printf '%s\n\n' $"removing uninstalled clones from AUR clone cache..."
                    for i in "${aurpkgsbase[@]}"; do
                        [[ -d "${clonedir}/${i}" ]] && rm -rf "${clonedir:?}/${i}"
                    done
                fi
            else
                if Proceed y $"Do you want to remove all uninstalled clones from AUR clone directory?"; then
                    printf '%s\n\n' $"removing uninstalled clones from AUR clone cache..."
                    for i in "${clonedir:?}/"*; do
                        [[ ! -d "${i}" || " ${foreignpkgsbase[*]} " = *" ${i} "* ]] ||
                            rm -rf "${clonedir:?}/${i}"
                    done
                fi
                if [[ ! "${PKGDEST}" || ! "${SRCDEST}" ]]; then
                    if Proceed y $"Do you want to remove all untracked files from AUR clone directory?"; then
                        printf '%s\n' $"removing untracked files from AUR clone cache..."
                        for i in "${clonedir:?}/"*; do
                            [[ -d "${i}" ]] &&
                                git --git-dir="${i}/.git" --work-tree="${i}" clean -ffdx &>/dev/null
                        done
                    fi
                fi
            fi
        else
            if ! Proceed n $"Do you want to remove ALL clones from AUR clone directory?"; then
                printf '%s\n' $"removing all clones from AUR clone cache..."
                for i in "${clonedir:?}/"*; do
                    [[ -d "${i}" ]] && rm -rf "${i}"
                done
            fi
        fi
    fi
    exit "${E_OK}"
}

GetIgnoredPkgs() {
    # global ignoredpkgs
    mapfile -tO "${#ignoredpkgs[@]}" ignoredpkgs < <(pacman-conf IgnorePkg)
    ignoredpkgs=("${ignoredpkgs[@]//,/ }")
}

GetIgnoredGrps() {
    # global ignoredgrps
    mapfile -tO "${#ignoredgrps[@]}" ignoredgrps < <(pacman-conf IgnoreGroup)
    ignoredgrps=("${ignoredgrps[@]//,/ }")
}

GetInstallScripts() {
    local installscriptspath
    # global installscripts
    [[ -d "${clonedir}/$1" ]] || return
    unset installscriptspath installscripts
    shopt -s nullglob
    installscriptspath=("${clonedir}/$1/"*'.install')
    shopt -u nullglob
    [[ "${installscriptspath[*]}" ]] && installscripts=("${installscriptspath[@]##*/}")
}

GetBuiltPkg() {
    local ext
    # global builtpkg
    # check PKGEXT suffix first, then default .xz suffix for repository packages in pacman cache
    # and lastly all remaining suffixes in case PKGEXT is locally overridden
    for ext in "${PKGEXT}" .pkg.tar{.xz,,.gz,.bz2,.lzo,.lrz,.Z}; do
        builtpkg="$2/$1-${CARCH}${ext}"
        [[ -f "${builtpkg}" ]] || builtpkg="$2/$1-any${ext}"
        [[ -f "${builtpkg}" ]] && break
    done
    [[ -f "${builtpkg}" ]] || { unset builtpkg; return 1; }
}

GetPkgbase() {
    local i
    # global pkgsbase basepkgs
    SetInfo "$@"
    for i in "$@"; do
        pkgsbase+=("$(GetInfo PackageBase "${i}")")
    done
    for i in "${pkgsbase[@]}"; do
        [[ " ${basepkgs[*]} " = *" ${i} "* ]] || basepkgs+=("${i}")
    done
}

SetInfo() {
    # Usage: SetInfo $@
    # Use auracle formatted info output for all aur packages passed to SetInfo, and sort it into
    # associated arrays
    local fields=(Name PackageBase Version Maintainer OutOfDate Groups {,Make,Check}Depends Provides Conflicts)
    local auracle_packages=("$@") cache_array=() info_arrays=() i j

    # cache previous info arrays in temporary arrays of the same names, but prefixed with c
    if [[ "${Name[*]}" ]]; then
        mapfile -t cache_array < <(declare -p "${fields[@]}")
        local -A "${cache_array[@]/#declare -A /c}"
    fi

    unset "${fields[@]}"
    [[ "$*" ]] || return
    declare -Ag "${fields[@]}"

    for i in "${!cName[@]}"; do
        if [[ " $* " = *" ${cName[${i}]} "* ]]; then
            for j in "${!auracle_packages[@]}"; do
                [[ "${cName[${i}]}" != "${auracle_packages[j]}" ]] || unset "auracle_packages[${j}]"
            done
            Name[${i}]="${cName[${i}]}"
            PackageBase[${i}]="${cPackageBase[${i}]}"
            Version[${i}]="${cVersion[${i}]}"
            Maintainer[${i}]="${cMaintainer[${i}]}"
            OutOfDate[${i}]="${cOutOfDate[${i}]}"
            Groups[${i}]="${cGroups[${i}]}"
            Depends[${i}]="${cDepends[${i}]}"
            MakeDepends[${i}]="${cMakeDepends[${i}]}"
            CheckDepends[${i}]="${cCheckDepends[${i}]}"
            Provides[${i}]="${cProvides[${i}]}"
            Conflicts[${i}]="${cConflicts[${i}]}"
        fi
    done

    if [[ "${auracle_packages[*]}" ]]; then
        mapfile -t info_arrays < <(auracle info "${auracle_packages[@]}" -F \
            $'Name[{name}]={name}\nPackageBase[{name}]={pkgbase}\nVersion[{name}]={version}\nMaintainer[{name}]={maintainer}\nOutOfDate[{name}]={outofdate:%s}\nGroups[{name}]={groups:\037}\nDepends[{name}]={depends:\037}\nMakeDepends[{name}]={makedepends:\037}\nCheckDepends[{name}]={checkdepends:\037}\nProvides[{name}]={provides:\037}\nConflicts[{name}]={conflicts:\037}')
        [[ ! "${info_arrays[*]}" ]] || declare -g "${info_arrays[@]}"
   fi
}

GetInfo() {
    local -n field="$1"

    if [[ "$2" ]]; then
        printf '%s\n' "${field[$2]//$'\037'/ }"
    else
        printf '%s\n' "${field[@]//$'\037'/ }"
    fi
}

CheckRequires() {
    local -a Qrequires
    mapfile -t Qrequires < <(expac -Ql'\n' '%N' "$@")
    if [[ "${Qrequires[*]}" ]]; then
        fail $"failed to prepare transaction (could not satisfy dependencies)"
        error $"%s: requires %s" "${Qrequires[*]}" "$*" "${E_INSTALL_DEPS_FAILED}"
    fi
}

Proceed() {
    local answer ret readline=0

    if [[ "${TERM}" = dumb ]] || ((cleancache)); then
        readline=1
    fi
    case "$1" in
        y)  printf "%s::%s %s$2 [Y/n] %s" "${colorB}" "${reset}" "${colorW}" "${@:3}" "${reset}"
            if ((noconfirm)); then
                printf '\n'
                return 0
            fi
            while true; do
                if ((readline)); then
                    read -r answer
                else
                    read -rsn 1 answer
                fi
                case "${answer}" in
                    [Yy]|'') ret=0; break;;
                    [Nn]) ret=1; break;;
                    *) ((readline)) && ret=1 && break;;
                esac
            done;;
        n)  printf "%s::%s %s$2 [y/N] %s" "${colorB}" "${reset}" "${colorW}" "${@:3}" "${reset}"
            if ((noconfirm)); then
                printf '\n'
                return 0
            fi
            while true; do
                if ((readline)); then
                    read -r answer
                else
                    read -rsn 1 answer
                fi
                case "${answer}" in
                    [Nn]|'') ret=0; break;;
                    [Yy]) ret=1; break;;
                    *) ((readline)) && ret=0 && break;;
                esac
            done;;
    esac
    ((readline)) || printf '%s\n' "${answer}"
    return "${ret}"
}

info() {
    printf "%s::%s $1\n" "${colorB}" "${reset}" "${@:2}"
}

warn() {
    printf "%swarning:%s $1\n" "${colorY}" "${reset}" "${@:2}" >&2
}

fail() {
    printf "%serror:%s $1\n" "${colorR}" "${reset}" "${@:2}" >&2
}

error() {
    printf "%serror:%s $1\n" "${colorR}" "${reset}" "${@:2:$#-2}" >&2
    exit "${!#}"
}

GetLength() {
    local length=0 i
    for i in "$@"; do
        x="${#i}"
        ((x > length)) && length="${x}"
    done
    printf '%s\n' "${length}"
}

NothingToDo() {
    [[ ! "$*" ]] && printf '%s\n' $" there is nothing to do" && exit "${E_OK}" || return 0
}

SudoV() {
    : >"${tmpdir}/pacaur.sudov.lck"
    while [[ -e "${tmpdir}/pacaur.sudov.lck" ]]; do
        sudo "${pacmanbin}" -V >/dev/null
        sleep 298
    done
}

CommArr() {
    # args are names of 2 arrays and outputs elements that are only in the 2nd
    local array1="$1[@]" array2="$2[@]"
    comm <(sort -u <(printf '%s\n' "${!array1-}")) <(sort -u <(printf '%s\n' "${!array2-}")) "$3"
}

trap Cancel INT
Cancel() {
    printf '\n'
    rm -f "${tmpdir:?}"/pacaur.{build,sudov}.lck
    exit
}

Usage() {
    printf '%s\n' $"usage:  pacaur <operation> [options] [target(s)] -- See also pacaur(8)"
    printf '%s\n' $"operations:"
    printf '%s\n' $" pacman extension"
    printf '%s\n' $"   -S, -Ss, -Si, -Sw, -Su, -Qu, -Sc, -Scc"
    printf '%s\n' $"                    extend pacman operations to the AUR"
    printf '%s\n' $" general"
    printf '%s\n' $"   -v, --version    display version information"
    printf '%s\n' $"   -h, --help       display help information"
    printf '\n'
    printf '%s\n' $"options:"
    printf '%s\n' $" pacman extension - can be used with the -S, -Ss, -Si, -Sw, -Su, -Sc, -Scc operations"
    printf '%s\n' $"   -a, --aur        only search, build, install or clean target(s) from the AUR"
    printf '%s\n' $"   -r, --repo       only search, build, install or clean target(s) from the repositories"
    printf '%s\n' $" general"
    printf '%s\n' $"   -e, --edit       edit target(s) PKGBUILD and view install script"
    printf '%s\n' $"   -q, --quiet      show less information for query and search"
    printf '%s\n' $"   --devel          consider AUR development packages upgrade"
    printf '%s\n' $"   --foreign        consider already installed foreign dependencies"
    printf '%s\n' $"   --ignore         ignore a package upgrade (can be used more than once)"
    printf '%s\n' $"   --needed         do not reinstall already up-to-date target(s)"
    printf '%s\n' $"   --noconfirm      do not prompt for any confirmation"
    printf '%s\n' $"   --noedit         do not prompt to edit files"
    printf '%s\n' $"   --rebuild        always rebuild package(s)"
    printf '%s\n' $"   --silent         silence output"
    exit "${E_OK}"
}

#
# Main
#

# options
shortopts="DFQRSTUVacdefghiklmnopqrstuvwxy"
longopts=('help' 'database' 'files' 'query' 'remove' 'sync' 'deptest' 'upgrade')
longopts+=('asdeps' 'asexplicit' 'cascade' 'changelog' 'check' 'confirm' 'dbonly' 'debug' 'deps'
           'disable-download-timeout' 'downloadonly' 'explicit' 'file' 'foreign' 'groups' 'info'
           'list' 'machinereadable' 'native' 'needed' 'noconfirm' 'nodeps' 'noprogressbar' 'nosave'
           'noscriptlet' 'owns' 'print' 'recursive' 'refresh' 'regex' 'quiet' 'search' 'sysupgrade'
           'unneeded' 'unrequired' 'upgrades' 'verbose')
longopts+=('arch:' 'assume-installed:' 'cachedir:' 'color:' 'config:' 'dbpath:' 'gpgdir:' 'hookdir:'
           'ignore:' 'ignoregroup:' 'logfile:' 'overwrite:' 'print-format:' 'root:' 'sysroot:')
longopts_aur=('aur' 'by:' 'devel' 'edit' 'literal' 'noedit' 'rebuild' 'repo' 'rsort:' 'searchby:'
              'silent' 'sort:' 'update' 'version')
parseopts "${shortopts}" "${longopts[@]}" "${longopts_aur[@]}" -- "$@" || exit "${E_INVALID_OPTION}"
set -- "${OPTRET[@]}"

while true; do
    [[ "$1" != -[cdf-qs-zDFQRSTUV] ]] || pacmanarg+=("$1")
    for i in "${longopts[@]}"; do
        [[ "$1" != '--'@(version|database|files|query|remove|sync|deptest|upgrade) ]] ||
            { tmp="${1:1:2}" pacmanarg+=("${tmp^^}"); break; }
        [[ "$1" != "--${i}" ]] || pacopts+=("$1")
        [[ "$1": != "--${i}" ]] || pacopts+=("$1=$2")
    done
    case "$1" in
        -S|--sync) pacS=1; installpkg=1; operation='sync'; ((++pac));;
        -Q|--query) pacQ=1; ((++pac));;
        -s|--search) search=1;;
        -i|--info) info=1;;
        -e|--edit) pace=1;;
        -u|--upgrades|--sysupgrade) upgrade=1; installpkg=1;;
        -q|--quiet) declare -x QUIET=1; auropts+=("$1");;
        -c|--clean) cleancache=1 && ((++ccount));;
        -n|--native) native=1;;
        -r|--repo) repo=1;;
        -a|--aur) aur=1;;
        --ignore) ignoredpkgs+=("$2"); shift;;
        --color) color="$2"; shift;;
        --literal) auropts+=("$1");;
        --@(by|searchby)) auropts+=("--searchby=$2"); shift;;
        --sort) sortorder='ascending' sortby="$2"; shift;;
        --rsort) sortorder='descending' sortby="$2"; shift;;
        -d|--nodeps) nodeps=1; makeopts+=("$1"); ((++dcount));;
        --assume-installed) assumeinstalled+=("$2"); shift;;
        -[DFRTUV]|--@(database|files|remove|deptest|upgrade)) ((++pac));;
        --@(asdeps|asexplicit|devel|needed|noconfirm|noedit|rebuild)) declare "${1/--}"=1;;
        -[glp]|--@(groups|list|print)) noop=1;;
        -w|--downloadonly) downloadonly=1;;
        --silent) silent='true' pacopts+=('--quiet') auropts+=('--quiet') makeopts+=('--log');;
        -y|--refresh) refresh=1;;
        -h|--help) help=1;;
        --version) operation='version'; ((++pac));;
        -v) ver=1;;
        --) shift; break;;
    esac
    shift
done

# help or version
[[ "${operation}" = version ]] || ((! pac && ver)) && printf '%s\n' "pacaur ${version}" && exit "${E_OK}"
((! pac && help)) && Usage

# sorting
case "${sortorder}" in
    ascending)  auropts+=("--sort=${sortby}");;
    descending) auropts+=("--rsort=${sortby}");;
esac

# packages
pkgs=("$@")

# color
[[ ! "${color}" && (! "$(pacman-conf Color)" || "${operation}" = upgrades ||
    "${QUIET}" -ne 0 && "${search}" -ne 0) ]] && color='never' || color='auto'
pacopts+=("--color=${color}") auropts+=("--color=${color}")
if [[ "${color}" != 'never' ]]; then
    declare -r reset=$'\033[0m' colorR=$'\033[1;31m' colorG=$'\033[1;32m' colorY=$'\033[1;33m' \
        colorB=$'\033[1;34m' colorM=$'\033[1;35m' colorW=$'\033[1;39m'
else
    declare -r reset='' colorR='' colorG='' colorY='' colorB='' colorM='' colorW=''
    makeopts+=('-m')
fi

# sanity check
((! aur)) || refresh=0
((! pace || pac)) || operation='edit'
((! pacQ || ! pace)) || pacopts+=('-e')
((! pacQ || ! upgrade)) || operation='upgrades'
((! pacQ || ! native)) || repo=1
((! pacS || ! downloadonly)) || installpkg=0
((! pacS || ! noop)) || operation=''
((! pacS || ! cleancache)) || search=0 info=0 upgrade=0
if ((pac > 1)); then
    error $"only one operation may be used at a time" "${E_FAIL}"
fi
if [[ "${operation}" = sync ]] && ((! search && ! info && ! cleancache && ! EUID)); then
    error $"you cannot perform this operation as root" "${E_ROOT}"
fi
((! pacS || ! search || ! info)) ||
    error $"invalid option: '--info' and '--search' may not be used together" "${E_INVALID_OPTION}"
command -v "${editor%% *}" >/dev/null ||
    error $"%s\$VISUAL%s and %s\$EDITOR%s environment variables not set or defined %seditor%s not found" \
        "${colorW}" "${reset}" "${colorW}" "${reset}" "${colorW}" "${reset}" "${E_MISSING_FILE}"
[[ "${PACMAN-}" != "${0##*/}" ]] ||
    error $"you cannot use %spacaur%s as PACMAN environment variable" "${colorW}" "${reset}" "${E_FAIL}"
[[ -w "${clonedir}" ]] ||
    error $"%s does not have write permission" "${colorW}${clonedir}${reset}" "${E_FS_PERMISSIONS}"
if [[ ! "${pkgs[*]}" && "${operation}" = @(sync|edit) ]] &&
    ! ((help + refresh + upgrade + cleancache + info)); then
        error $"no targets specified (use -h for help)" "${E_FAIL}"
fi
if [[ ! "${pkgs[*]}" && " ${pacmanarg[*]} " = *' -'[RU]' '* ]] && ((! help)); then
    error $"no targets specified (use -h for help)" "${E_FAIL}"
fi
((! repo || ! aur)) || { aur=0 repo=0
    warn $"invalid option: '-r/--repo' and '-a/--aur' may not be used together, disabling both"; }

# operations
case "${operation}" in
    edit) # edit (-e) handling
        GetPkgbase "${pkgs[@]}"
        EditPkgs "${pkgsbase[@]}"
        exit;;
    sync)
        # search (-Ss, -s) handling
        if ((search)); then
            if ((! aur)); then
                if ((refresh)); then
                    sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
                else
                    "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
                fi
                exitrepo="$?"
            fi
            if ((! repo)); then
                auracle search "${auropts[@]}" -- "${pkgs[@]#aur/}"; exitaur="$?"
            fi
            # exit code
            ((! exitrepo || ! exitaur)) && exit "${E_OK}" || exit "${E_FAIL}"
        # info (-Si, -i) handling
        elif ((info)); then
            if [[ ! "${pkgs[*]}" ]] && ((refresh)); then
                sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}"
            elif [[ ! "${pkgs[*]}" ]]; then
                "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}"
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                if ((refresh)); then
                    sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" "${repopkgs[@]}"
                else
                    "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" "${repopkgs[@]}"
                fi
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                if ((refresh)) && [[ ! "${repopkgs[*]}" ]]; then
                    sudo "${pacmanbin}" -Sy "${pacopts[@]}"
                fi
                if ((! aur)); then
                    info $"Package(s) %s not found in repositories, trying %sAUR%s..." \
                        "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
                fi
                auracle info "${auropts[@]}" -- "${aurpkgs[@]}"
            fi
        # clean (-Sc) handling
        elif ((cleancache)); then
            if ((! aur)); then
                sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" "${repopkgs[@]}"
            fi
            if ((! repo)); then
                CleanCache "${pkgs[@]}"
            fi
        # sysupgrade (-Su, -u) handling
        elif ((upgrade)); then
            [[ "${pkgs[*]}" ]] && ClassifyPkgs "${pkgs[@]}"
            if ((! aur)); then
                if ! sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" "${repopkgs[@]}" && ((repo)); then
                    exit "${E_FAIL}"
                fi
            fi
            if [[ "${aurpkgs[*]}" ]] && ((! aur)); then
                info $"Package(s) %s not found in repositories, trying %sAUR%s..." \
                    "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
            fi
            if ((! repo)); then
                Core
            fi
        elif ((help)); then
            "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
        # sync (-S, -y), downloadonly (-Sw, -m), refresh (-Sy)
        else
            if [[ ! "${pkgs[*]}" ]]; then
                sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}"
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" "${repopkgs[@]}"
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                if ((refresh)) && [[ ! "${repopkgs[*]}" ]]; then
                    sudo "${pacmanbin}" -Sy "${pacopts[@]}"
                fi
                if ((! aur)); then
                    info $"Package(s) %s not found in repositories, trying %sAUR%s..." \
                        "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
                fi
                Core
            fi
        fi
        exit;;
    upgrades) # upgrades (-Qu) handling
        if ((! aur)); then
            "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
        fi
        exitrepo="$?"
        if ((! repo)); then
            [[ "${pkgs[*]}" ]] ||
                mapfile -t pkgs < <("${pacmanbin}" -qm "${pacmanarg[@]//-u}" "${pacopts[@]//--upgrades}")
            auracle sync "${auropts[@]}" -- "${pkgs[@]}"
            exitaur="$?"
        fi
        if ((! exitrepo || ! exitaur)); then
            exit "${E_OK}"
        else
            exit "${E_FAIL}"
        fi;;
    *)  if [[ " ${pacmanarg[*]} " = *' -F '* ]] && ((refresh)); then
            sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
        elif [[ ! "${pkgs[*]}" || " ${pacmanarg[*]} " = *' -'[DFQTglp]' '* ]] &&
            ((! asdeps && ! asexplicit)); then
                "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
        else
            sudo "${pacmanbin}" "${pacmanarg[@]}" "${pacopts[@]}" -- "${pkgs[@]}"
        fi
        exit;; # others operations handling
esac

# vim:set ts=4 sw=4 et:
