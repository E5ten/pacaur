#!/bin/bash
#
# pacaur: an AUR helper that minimizes user interaction
#

shopt -s extglob

# gettext initialization
export LC_COLLATE=C
export TEXTDOMAIN='pacaur'
export TEXTDOMAINDIR='/usr/share/locale'

declare -r version='4.8.6'

#
# Config
#

# Options
aur=0 asdeps=0 asexplicit=0 checkdeps=0 cleancache=0 ccount=0 color='' dcount=0
devel=0 downloadonly=0 help=0 info=0 installpkg=0 native=0 needed=0 noconfirm=0
nodeps=0 noedit=0 noop=0 operation='' pac=0 pace=0 pacQ=0 pacS=0 rebuild=0
refresh=0 repo=0 search=0 upgrade=0 ver=0

pacmanarg=()
pacopts=()
auropts=()
makeopts=()

# determine config location
if [[ "${XDG_CONFIG_DIRS-}" ]]; then
    while IFS=: read -rd: i; do
        if [[ -d "$i/pacaur" ]]; then
            export XDG_CONFIG_DIRS="$i"
            break
        fi
    done <<<"${XDG_CONFIG_DIRS}:"
fi
configdir="${XDG_CONFIG_DIRS:-/etc/xdg}/pacaur"
userconfigdir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacaur"
userpacmandir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacman"
usercachedir="${XDG_CACHE_HOME:-${HOME}/.cache}/pacaur"
tmpdir="${XDG_RUNTIME_DIR:-/tmp}"

# preserve environment variables
var=('PACMAN' {'PKG','SRC'}{'DEST','EXT'} {'SRCPKG','LOG'}'DEST' 'BUILDDIR' 'GPGKEY' 'PACKAGER' 'CARCH')
for i in "${var[@]}"; do
    [[ ! "${!i-}" ]] || declare _"$i"="${!i}"
done
: "${PKGDEST=${PKGDEST-}}"

# source makepkg variables
if [[ -r "${MAKEPKG_CONF-}" ]]; then
    source "$MAKEPKG_CONF"
else
    source /etc/makepkg.conf
    if [[ -r "$userpacmandir/makepkg.conf" ]]; then
        source "$userpacmandir/makepkg.conf"
    elif [[ -r "$HOME/.makepkg.conf" ]]; then
        source "$HOME/.makepkg.conf"
    fi
fi

# restore environment variables
for i in "${var[@]/#/_}"; do
    [[ ! "${!i-}" ]] || declare -x "${i//_}"="${!i:-${!i//_}}"
done

# set default config variables
editor="${VISUAL:-"${EDITOR:-vi}"}"         # build files editor
displaybuildfiles='diff'                    # display build files (none|diff|full)
silent='false'                              # silence output
sortby='name'                               # sort method (name|votes|popularity)
sortorder='ascending'                       # sort order (ascending|descending)
sudoloop='true'                             # prevent sudo timeout

# set variables
declare -r pacmanbin="${PACMAN:-pacman}"    # pacman binary
clonedir="${AURDEST:-${usercachedir:?}}"    # clone directory

# source xdg config
[[ -r "$configdir/config" ]] && source "$configdir/config"
[[ -r "$userconfigdir/config" ]] && source "$userconfigdir/config"

# source makepkg libraries
for i in parseopts util option error; do
    source "/usr/share/makepkg/util/$i.sh"
done
if check_buildoption check y; then
    checkdeps=1
fi

# determine whether we have gettext; make it a no-op if we do not
type -p gettext >/dev/null || gettext() { printf '%s\n' "$@"; }

# define vcs packages
declare -r vcs='-(cvs|svn|git|hg|bzr|darcs|daily.*|nightly.*)$'

# set variables to readonly and setup clonedir
declare -r {clone,config,user{config,pacman,cache},tmp}dir
[[ -d "$clonedir" && -w "$clonedir" ]] || install -dm700 "$clonedir"

#
# Functions
#

ClassifyPkgs() {
    local noaurpkgs norepopkgs
    # global aurpkgs repopkgs
    if ((repo)); then
        repopkgs=("${pkgs[@]}")
    fi
    if ((aur)); then
        aurpkgs=("${pkgs[@]#aur/}") # search aur/pkgs in AUR
    fi
    if ((! repo && ! aur)); then
        noaurpkgs=()
        for i in "${pkgs[@]}"; do
            if [[ "$i" = aur/* ]]; then
                aurpkgs+=("${i:4}") # search aur/pkgs in AUR
                continue
            fi
            noaurpkgs+=("$i")
        done
        [[ "${noaurpkgs[*]}" ]] &&
            IFS=$'\n' mapfile -t < <(LC_ALL=C "$pacmanbin" -Sp "${noaurpkgs[@]}" 2>&1 >/dev/null) norepopkgs &&
                norepopkgs=("${norepopkgs[@]#error: target not found: }")
        for i in "${norepopkgs[@]}"; do
            # do not search repo/pkgs in AUR
            [[ " ${noaurpkgs[*]} " =~ [a-zA-Z0-9\.\+-]+\/"$i"[^a-zA-Z0-9\.\+-] ]] || aurpkgs+=("$i")
        done
        repopkgs=($(CommArr 'aurpkgs' 'noaurpkgs' '-13'))
    fi
}

Core() {
    GetIgnoredPkgs
    GetIgnoredGrps
    ((upgrade)) && UpgradeAur
    IgnoreChecks
    DepsSolver
    IgnoreDepsChecks
    ProviderChecks
    ConflictChecks
    ReinstallChecks
    OutOfDateChecks
    OrphanChecks
    Prompt
    MakePkgs
}

UpgradeAur() {
    local foreignpkgs allaurpkgs aurforeignpkgs i
    # global aurpkgs
    info $"%sStarting AUR upgrade...%s" "${colorW}" "${reset}"
    foreignpkgs=($("$pacmanbin" -Qmq))
    SetInfo "${foreignpkgs[@]}"
    allaurpkgs=($(GetInfo "Name"))

    # foreign packages check
    aurforeignpkgs=($(CommArr 'allaurpkgs' 'foreignpkgs' '-13'))
    for i in "${aurforeignpkgs[@]}"; do
        warn $"%s is %snot present%s in AUR -- skipping" "${colorW}$i${reset}" "${colorY}" "${reset}"
    done

    # use auracle to find out of date AUR packages
    mapfile -t < <(auracle sync -q) aurpkgs

    # add devel packages
    if ((devel)); then
        for i in "${allaurpkgs[@]}"; do
            [[ "$i" =~ $vcs && ! " ${aurpkgs[*]} " = *" $i "* ]] && aurpkgs+=("$i")
        done
    fi

    aurpkgs+=("${pkgs[@]}")

    # avoid possible duplicate
    aurpkgs=($(printf '%s\n' "${aurpkgs[@]}" | sort -u))

    NothingToDo "${aurpkgs[@]}"
}

IgnoreChecks() {
    local checkaurpkgs checkaurpkgsAver checkaurpkgsQver checkaurpkgsgrp i
    # global aurpkgs rmaurpkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # check targets
    SetInfo "${aurpkgsnover[@]}"
    checkaurpkgs=($(GetInfo "Name"))
    errdeps=($(CommArr 'aurpkgsnover' 'checkaurpkgs' '-3'))
    aurpkgsnover=()

    checkaurpkgsAver=($(GetInfo "Version"))
    mapfile -t < <(expac -Qv '%v' "${checkaurpkgs[@]}" 2>&1) checkaurpkgsQver
    for i in "${!checkaurpkgs[@]}"; do
        [[ "${checkaurpkgs[$i]}" =~ $vcs ]] && checkaurpkgsAver[$i]=$"latest"
        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" ${checkaurpkgs[$i]} "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            checkaurpkgsgrp=($(GetInfo "Groups" "${checkaurpkgs[$i]}"))
            checkaurpkgsgrp+=($(expac -Q '%G' "${checkaurpkgs[$i]}"))
            for j in "${checkaurpkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " = *" $j "* ]] && isignored=1
            done
        fi

        if ((isignored)); then
            if ((! upgrade)); then
                if ((! noconfirm)); then
                    if ! Proceed "y" $"${checkaurpkgs[$i]} is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                        warn $"skipping target: %s" "${colorW}${checkaurpkgs[i]}${reset}"
                        rmaurpkgs+=("${checkaurpkgs[$i]}")
                        continue
                    fi
                else
                    warn $"skipping target: %s" "${colorW}${checkaurpkgs[i]}${reset}"
                    rmaurpkgs+=("${checkaurpkgs[$i]}")
                    continue
                fi
            else
                warn $"%s: ignoring package upgrade (%s => %s)" "${colorW}${checkaurpkgs[i]}${reset}" "${colorR}${checkaurpkgsQver[i]}${reset}" "${colorG}${checkaurpkgsAver[i]}${reset}"
                rmaurpkgs+=("${checkaurpkgs[$i]}")
                continue
            fi
        fi
        aurpkgsnover+=("${checkaurpkgs[$i]}")
    done

    aurpkgs=("${aurpkgsnover[@]}")
    NothingToDo "${aurpkgs[@]}"
}

DepsSolver() {
    local i aurpkgsconflicts
    # global aurpkgs aurpkgsnover aurpkgsproviders aurdeps deps errdeps
    # global errdepsnover foreignpkgs repodeps depsAname depsAver depsAood depsQver
    printf '%s\n' $"resolving dependencies..."

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # set unversioned info
    SetInfo "${aurpkgsnover[@]}"

    # set targets providers
    aurpkgsproviders=("${aurpkgsnover[@]}")
    aurpkgsproviders+=($(GetInfo "Provides"))
    aurpkgsproviders=("${aurpkgsproviders[@]%%[><=]*}")

    # check targets conflicts
    aurpkgsconflicts=($(GetInfo "Conflicts"))
    if [[ "${aurpkgsconflicts[*]}" ]]; then
        aurpkgsconflicts=("${aurpkgsconflicts[@]%%[><=]*}")
        aurpkgsconflicts=($(CommArr 'aurpkgsproviders' 'aurpkgsconflicts' '-12'))
        for i in "${aurpkgsconflicts[@]}"; do
            [[ " ${aurpkgsnover[*]} " = *" $i "* ]] || continue
            [[ " $(GetInfo "Conflicts" "$i") " = *" $i "* ]] && continue
            fail $"unresolvable package conflicts detected"
            error $"failed to prepare transaction (conflicting dependencies: %s)" "$i" "$E_INSTALL_DEPS_FAILED"
        done
    fi

    deps=("${aurpkgsnover[@]}")

    [[ "${foreignpkgs[*]}" ]] || foreignpkgs=($("$pacmanbin" -Qmq))
    FindDepsAur "${aurpkgsnover[@]}"

    # avoid possible duplicate
    deps=($(CommArr 'aurdepspkgs' 'deps' '-13'))
    deps+=("${aurdepspkgs[@]}")

    # ensure correct dependency order
    SetInfo "${deps[@]}"
    SortDepsAur "${aurpkgs[@]}"
    deps=($(tsort <<< "${tsortdeps[@]}")) || error $"dependency cycle detected" "$E_INSTALL_DEPS_FAILED"

    # get AUR packages info
    depsAname=($(GetInfo "Name"))
    depsAver=($(GetInfo "Version"))
    depsAood=($(GetInfo "OutOfDate"))
    depsAmain=($(GetInfo "Maintainer"))
    for i in "${!depsAname[@]}"; do
        read -rd' ' < <(expac -Qs '%v' "^${depsAname[$i]}$") depsQver[$i]
        [[ "${depsQver[$i]}" ]] || depsQver[$i]="%"  # avoid empty elements shift
        [[ "${depsAname[$i]}" =~ $vcs ]] && depsAver[$i]=$"latest"
    done

    # no results check
    if [[ "${errdeps[*]}" ]]; then
        for i in "${!errdepsnover[@]}"; do
            if [[ " ${aurpkgsnover[*]} " = *" ${errdepsnover[$i]} "* ]]; then
                fail $"no results found for %s" "${errdeps[$i]}"
            else
                unset tsorterrdeps errdepslist currenterrdep
                # find relevant tsorted deps chain
                for j in "${deps[@]}"; do
                    tsorterrdeps+=("$j")
                    [[ "$j" = "${errdepsnover[$i]}" ]] && break
                done
                # reverse deps order
                for j in "${!tsorterrdeps[@]}"; do
                    tsorterrdepsrev[$j]="${tsorterrdeps[-j-1]}"
                done
                tsorterrdeps=("${tsorterrdepsrev[@]}") && unset tsorterrdepsrev
                errdepslist+=("${tsorterrdeps[0]}")
                FindDepsAurError "${tsorterrdeps[@]}"
                for j in "${!errdepslist[@]}"; do
                    [[ "${errdepslist[-j-1]}" ]] && errdepslistrev+=("${errdepslist[-j-1]}")
                done
                errdepslist=("${errdepslistrev[@]}") && unset errdepslistrev
                fail $"no results found for %s (dependency tree: %s)" "${errdeps[$i]}" "${errdepslist[*]}"
            fi
        done
        exit "$E_INSTALL_DEPS_FAILED"
    fi

    # return all binary deps
    FindDepsRepo "${repodeps[@]}"

    # avoid possible duplicate
    repodepspkgs=($(printf '%s\n' "${repodepspkgs[@]}" | sort -u))
}

FindDepsAur() {
    local depAname depAver depspkgs depspkgsaurtmp builtpkg vcsdepspkgs assumedepspkgs aurversionpkgs
    local aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff i j
    # global aurpkgsnover depspkgsaur errdeps repodeps aurdepspkgs prevdepspkgsaur foreignpkgs
    ((nodeps && dcount >= 2)) && return

    # set info
    unset aurversionpkgs
    if [[ "${depspkgsaur[*]}" ]]; then
        SetInfo "${depspkgsaur[@]}"
        aurversionpkgs=("${prevdepspkgsaur[@]}")
    else
        SetInfo "${aurpkgsnover[@]}"
        aurversionpkgs=("${aurpkgs[@]}")
    fi

    # versioning check
    if [[ "${aurversionpkgs[*]}" ]]; then
        for i in "${!aurversionpkgs[@]}"; do
            unset aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff
            aurversionpkgsname="${aurversionpkgs[$i]%%[><=]*}"
            aurversionpkgsver="${aurversionpkgs[$i]##*[><=]}"
            aurversionpkgsaurver="$(GetInfo "Version" "$aurversionpkgsname")"
            aurversionpkgsverdiff="$(vercmp "$aurversionpkgsaurver" "$aurversionpkgsver")"

            # not found in AUR nor repo
            [[ ! "$aurversionpkgsaurver" && ! " ${errdeps[*]} " = *" ${aurversionpkgs[$i]} "* ]] &&
                errdeps+=("${aurversionpkgs[$i]}") && continue

            case "${aurversionpkgs[$i]}" in
                *">"*|*"<"*|*"="*)
                    # found in AUR but version not correct
                    case "${aurversionpkgs[$i]}" in
                        *">="*) ((aurversionpkgsverdiff >= 0)) && continue;;
                        *"<="*) ((aurversionpkgsverdiff <= 0)) && continue;;
                        *">"*)  ((aurversionpkgsverdiff > 0))  && continue;;
                        *"<"*)  ((aurversionpkgsverdiff < 0))  && continue;;
                        *"="*)  ((aurversionpkgsverdiff == 0)) && continue;;
                    esac
                    [[ " ${errdeps[*]} " = *" ${aurversionpkgs[$i]} "* ]] ||
                        errdeps+=("${aurversionpkgs[$i]}");;
                *) continue;;
            esac
        done
    fi

    depspkgs=($(GetInfo "Depends"))

    # cached packages makedeps check
    if [[ ! "$PKGDEST" ]] || ((rebuild)); then
        depspkgs+=($(GetInfo "MakeDepends"))
        ((checkdeps)) && depspkgs+=($(GetInfo "CheckDepends"))
    else
        [[ ! "${depspkgsaur[*]}" ]] && depspkgsaurtmp=("${aurpkgs[@]}") ||
            depspkgsaurtmp=("${depspkgsaur[@]}")
        for i in "${!depspkgsaurtmp[@]}"; do
            depAname="$(GetInfo "Name" "${depspkgsaurtmp[$i]}")"
            depAver="$(GetInfo "Version" "${depspkgsaurtmp[$i]}")"
            GetBuiltPkg "$depAname-$depAver" "$PKGDEST"
            if [[ ! "$builtpkg" ]]; then
                depspkgs+=($(GetInfo "MakeDepends" "${depspkgsaurtmp[$i]}"))
                ((checkdeps)) && depspkgs+=($(GetInfo "CheckDepends"))
            fi
            unset builtpkg
        done
    fi

    # remove deps provided by targets
    [[ "${aurpkgsproviders[*]}" ]] && depspkgs=($(CommArr 'aurpkgsproviders' 'depspkgs' '-13'))

    # workaround for limited RPC support of architecture dependent fields
    if [[ "${CARCH}" = 'i686' ]]; then
        for i in "${!depspkgs[@]}"; do
            [[ "${depspkgs[$i]}" =~ ^(lib32-|gcc-multilib) ]] && unset "depspkgs[$i]"
        done
        depspkgs=($(printf '%s\n' "${depspkgs[@]}"))
    fi

    # remove versioning
    depspkgs=("${depspkgs[@]%%[><=]*}")
    # remove installed deps
    if ((! devel)); then
        depspkgs=($("$pacmanbin" -T -- "${depspkgs[@]}" | sort -u))
    else
        # check providers
        unset vcsdepspkgs
        for i in "${!depspkgs[@]}"; do
            unset j && read -rd' ' < <(expac -Qs '%n %P' "^${depspkgs[$i]}$") j
            if [[ "$j" ]]; then
                depspkgs[$i]="$j"
                ((devel)) && [[ ! " ${ignoredpkgs[*]} " = *" $j "* && "$j" =~ $vcs ]] &&
                    vcsdepspkgs+=("$j")
            else
                foreignpkgs+=("${depspkgs[$i]}")
            fi
        done
        # reorder devel
        depspkgs=($("$pacmanbin" -T -- "${depspkgs[@]}" | sort -u))
        depspkgs=($(CommArr 'depspkgs' 'vcsdepspkgs' '-3'))
    fi

    # split repo and AUR depends pkgs
    unset depspkgsaur
    if [[ "${depspkgs[*]}" ]]; then
        # remove all pkgs versioning
        if ((nodeps && dcount == 1)); then
            depspkgs=("${depspkgs[@]%%[><=]*}")
        # assume installed deps
        elif [[ "${assumeinstalled[*]}" ]]; then
            # remove versioning
            assumeinstalled=("${assumeinstalled[@]%%[><=]*}")
            for i in "${!assumeinstalled[@]}"; do
                unset assumedepspkgs
                for j in "${!depspkgs[@]}"; do
                    assumedepspkgs[$j]="${depspkgs[$j]%%[><=]*}"
                    [[ " ${assumedepspkgs[*]} " = *" ${assumeinstalled[$i]} "* ]] &&
                        depspkgs[$j]="${assumeinstalled[$i]}";
                done
            done
            depspkgs=($(CommArr 'assumeinstalled' 'depspkgs' '-13'))
        fi
        if [[ "${depspkgs[*]}" ]]; then
            IFS=$'\n' mapfile -t < <(LC_ALL=C "$pacmanbin" -Sp "${depspkgs[@]}" 2>&1 >/dev/null ) depspkgsaur &&
            depspkgsaur=("${depspkgsaur[@]#error: target not found: }")
            repodeps+=($(CommArr 'depspkgsaur' 'depspkgs' '-13'))
        fi
    fi
    unset depspkgs

    # remove duplicate
    [[ "${depspkgsaur[*]}" ]] && depspkgsaur=($(CommArr 'aurdepspkgs' 'depspkgsaur' '-13'))

    # dependency cycle check
    [[ "${prevdepspkgsaur[*]}" && "${prevdepspkgsaur[*]}" = "${depspkgsaur[*]}" ]] &&
        error $"dependency cycle detected (%s)" "${depspkgsaur[*]}" "$E_INSTALL_DEPS_FAILED"

    if [[ "${depspkgsaur[*]}" ]]; then
        # store for AUR version check
        ((nodeps)) || prevdepspkgsaur=("${depspkgsaur[@]}")
        # remove duplicates and versioning
        depspkgsaur=($(printf '%s\n' "${depspkgsaur[@]%%[><=]*}" | sort -u))
    fi

    [[ "${depspkgsaur[*]}" ]] && aurdepspkgs+=("${depspkgsaur[@]}") &&
        FindDepsAur "${depspkgsaur[@]}"
}

SortDepsAur() {
    local i j sortaurpkgs sortdepspkgs sortdepspkgsaur
    # global checkedsortdepspkgsaur allcheckedsortdepspkgsaur errdepsnover
    [[ "${checkedsortdepspkgsaur[*]}" ]] && sortaurpkgs=("${checkedsortdepspkgsaur[@]}") ||
        sortaurpkgs=("${aurpkgs[@]}")

    unset checkedsortdepspkgsaur
    for i in "${!sortaurpkgs[@]}"; do
        unset sortdepspkgs sortdepspkgsaur

        sortdepspkgs+=($(GetInfo "Depends" "${sortaurpkgs[$i]}"))
        sortdepspkgs+=($(GetInfo "MakeDepends" "${sortaurpkgs[$i]}"))
        ((checkdeps)) && sortdepspkgs+=($(GetInfo "CheckDepends"))

        # remove versioning
        errdepsnover=("${errdeps[@]%%[><=]*}")

        # check AUR deps only
        for j in "${!sortdepspkgs[@]}"; do
            sortdepspkgs[$j]="${sortdepspkgs[$j]%%[><=]*}"
            sortdepspkgsaur+=($(GetInfo "Name" "${sortdepspkgs[$j]}"))
            # add erroneous AUR deps
            [[ " ${errdepsnover[*]} " = *" ${sortdepspkgs[$j]} "* ]] &&
                sortdepspkgsaur+=("${sortdepspkgs[$j]}")
        done

        # prepare tsort list
        if [[ ! "${sortdepspkgsaur[*]}" ]]; then
            tsortdeps+=("${sortaurpkgs[$i]} ${sortaurpkgs[$i]}")
        else
            for j in "${!sortdepspkgsaur[@]}"; do
                tsortdeps+=("${sortaurpkgs[$i]} ${sortdepspkgsaur[$j]}")
            done
        fi

        # filter non checked deps
        sortdepspkgsaur=($(CommArr 'allcheckedsortdepspkgsaur' 'sortdepspkgsaur' '-13'))
        if [[ "${sortdepspkgsaur[*]}" ]]; then
            checkedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur=($(printf '%s\n' "${allcheckedsortdepspkgsaur[@]}" | sort -u))
        fi
    done
    if [[ "${checkedsortdepspkgsaur[*]}" ]]; then
        checkedsortdepspkgsaur=($(printf '%s\n' "${checkedsortdepspkgsaur[@]}" | sort -u))
        SortDepsAur "${checkedsortdepspkgsaur[@]}"
    fi
}

FindDepsAurError() {
    local i nexterrdep nextallerrdeps
    # global errdepsnover errdepslist tsorterrdeps currenterrdep

    for i in "${tsorterrdeps[@]}"; do
        [[ " ${errdepsnover[*]} " = *" $i "* || " ${errdepslist[*]} " = *" $i "* ]] || nexterrdep="$i" && break
    done

    [[ "${currenterrdep[*]}" ]] || currenterrdep="${tsorterrdeps[0]}"
    if [[ ! " ${aurpkgs[*]} " = *" $nexterrdep "* ]]; then
        nextallerrdeps=($(GetInfo "Depends" "$nexterrdep"))
        nextallerrdeps+=($(GetInfo "MakeDepends" "$nexterrdep"))
        ((checkdeps)) && nextallerrdeps+=($(GetInfo "CheckDepends"))

        # remove versioning
        nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

        [[ " ${nextallerrdeps[*]} " = *" $currenterrdep "* ]] && errdepslist+=("$nexterrdep") &&
            currenterrdep="${tsorterrdeps[0]}"
        tsorterrdeps=("${tsorterrdeps[@]:1}")
        FindDepsAurError "${tsorterrdeps[@]}"
    else
        for i in "${!aurpkgs[@]}"; do
            nextallerrdeps=($(GetInfo "Depends" "${aurpkgs[$i]}"))
            nextallerrdeps+=($(GetInfo "MakeDepends" "${aurpkgs[$i]}"))
            ((checkdeps)) && nextallerrdeps+=($(GetInfo "CheckDepends"))

            # remove versioning
            nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

            [[ " ${nextallerrdeps[*]} " = *" $currenterrdep "* ]] && errdepslist+=("${aurpkgs[$i]}")
        done
    fi
}

FindDepsRepo() {
    local allrepodepspkgs repodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${repodeps[*]}" ]] || return

    # reduce root binary deps
    repodeps=($(printf '%s\n' "${repodeps[@]}" | sort -u))

    # add initial repodeps
    [[ "${repodepspkgs[*]}" ]] || repodepspkgs=("${repodeps[@]}")

    # get non installed binary deps
    unset allrepodepspkgs repodepspkgstmp
    # no version check needed as all deps are repo deps
    [[ "${repodeps[*]}" ]] && allrepodepspkgs=($(expac -S1 '%E' "${repodeps[@]}"))
    [[ "${allrepodepspkgs[*]}" ]] && repodepspkgstmp=($("$pacmanbin" -T -- "${allrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${repodepspkgstmp[*]}" ]] && repodepspkgstmp=($(CommArr 'repodepspkgs' 'repodepspkgstmp' '-13'))
    [[ "${repodepspkgstmp[*]}" ]] && repodepspkgs+=("${repodepspkgstmp[@]}") &&
        repodeps=("${repodepspkgstmp[@]}") && FindDepsRepo "${repodeps[@]}"
}

FindDepsRepoProvider() {
    local allrepodepspkgs providerrepodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${providerspkgs[*]}" ]] || return

    # reduce root binary deps
    providerspkgs=($(printf '%s\n' "${providerspkgs[@]}" | sort -u))

    # get non installed repo deps
    unset allproviderrepodepspkgs providerrepodepspkgstmp
    [[ "${providerspkgs[*]}" ]] && allproviderrepodepspkgs=($(expac -S1 '%E' "${providerspkgs[@]}"))
    # no version check needed as all deps are binary
    [[ "${allproviderrepodepspkgs[*]}" ]] &&
        providerrepodepspkgstmp=($("$pacmanbin" -T -- "${allproviderrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${providerrepodepspkgstmp[*]}" ]] &&
        providerrepodepspkgstmp=($(CommArr 'repodepspkgs' 'providerrepodepspkgstmp' '-13'))

    [[ "${providerrepodepspkgstmp[*]}" ]] && repodepspkgs+=("${providerrepodepspkgstmp[@]}") &&
        providerspkgs=("${providerrepodepspkgstmp[@]}") && FindDepsRepoProvider "${providerspkgs[@]}"
}

IgnoreDepsChecks() {
    local i
    # global ignoredpkgs aurpkgs aurdepspkgs aurdepspkgsgrp repodepspkgsgrp rmaurpkgs deps repodepspkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # add checked targets and preserve tsorted order
    deps=("${deps[@]:0:${#aurpkgs[@]}}")

    # check dependencies
    for i in "${repodepspkgs[@]}"; do
        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" $i "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset repodepspkgsSgrp repodepspkgsQgrp
            repodepspkgsgrp=($(expac -S1 '%G' "$i"))
            repodepspkgsgrp+=($(expac -Q '%G' "$i"))
            for j in "${repodepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " = *" $j "* ]] && isignored=1
            done
        fi

        if ((isignored)); then
            ((! upgrade)) && warn $"skipping target: %s" "${colorW}$i${reset}" ||
                warn $"%s: ignoring package upgrade" "${colorW}$i${reset}"
            error $"Unresolved dependency '%s'" "${colorW}$i${reset}" "$E_INSTALL_DEPS_FAILED"
        fi
    done
    for i in "${aurdepspkgs[@]}"; do
        # skip already checked dependencies
        [[ " ${aurpkgs[*]} " = *" $i "* ]] && continue
        [[ " ${rmaurpkgs[*]} " = *" $i "* ]] &&
            error $"Unresolved dependency '%s'" "${colorW}$i${reset}" "$E_INSTALL_DEPS_FAILED"

        isignored=0
        if [[ " ${ignoredpkgs[*]} " = *" $i "* ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset aurdepspkgsgrp
            aurdepspkgsgrp=($(GetInfo "Groups" "$i"))
            aurdepspkgsgrp+=($(expac -Q '%G' "$i"))
            for j in "${aurdepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " = *" $j "* ]] && isignored=1
            done
        fi

        if ((isignored)); then
            if ((! noconfirm)); then
                if ! Proceed "y" $"$i dependency is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                    warn $"skipping target: %s" "${colorW}$i${reset}"
                    error $"Unresolved dependency '%s'" "${colorW}$i${reset}" "$E_INSTALL_DEPS_FAILED"
                fi
            else
                ((upgrade)) && warn $"%s: ignoring package upgrade" "${colorW}$i${reset}" ||
                    warn $"skipping target: %s" "${colorW}$i${reset}"
                error $"Unresolved dependency '%s'" "${colorW}$i${reset}" "$E_INSTALL_DEPS_FAILED"
            fi
        fi
        deps+=("$i")
    done
}

ProviderChecks() {
    local providersdeps providersdepsnover providers repodepspkgsprovided providerspkgs provided
    local nb providersnb
    # global repodepspkgs repoprovidersconflictingpkgs repodepsSver repodepsSrepo repodepsQver
    [[ "${repodepspkgs[*]}" ]] || return

    # filter directly provided deps
    noprovidersdeps=($(expac -S1 '%n' "${repodepspkgs[@]}"))
    providersdeps=($(CommArr 'noprovidersdeps' 'repodepspkgs' '-13'))

    # remove installed providers
    providersdeps=($("$pacmanbin" -T -- "${providersdeps[@]}" | sort -u))

    for i in "${!providersdeps[@]}"; do
        # check versioning
        unset providersdepsname providersdepsver providersdepsSname providersdepsSver
        providersdepsname="${providersdeps[$i]%%[><=]*}"
        providersdepsver="${providersdeps[$i]##*[><=]}"
        providersdepsSname=($(expac -Ss '%n' "^${providersdepsname[$i]}$"))
        providersdepsSver=($(expac -Ss '%v' "^${providersdepsname[$i]}$"))

        case "${providersdeps[$i]}" in
            *">"*|*"<"*|*"="*)
                for j in "${!providersdepsSname[@]}"; do
                    unset providersdepverdiff
                    providersdepsverdiff="$(vercmp "$providersdepsver" "${providersdepsSver[j]}")"
                    # found in repo but version not correct
                    case "${providersdeps[$i]}" in
                        *">="*) ((providersdepsverdiff >= 0)) && continue;;
                        *"<="*) ((providersdepsverdiff <= 0)) && continue;;
                        *">"*)  ((providersdepsverdiff > 0))  && continue;;
                        *"<"*)  ((providersdepsverdiff < 0))  && continue;;
                        *"="*)  ((providersdepsverdiff == 0)) && continue;;
                    esac
                    providersdepsnover+=("${providersdepsSname[j]}")
                done
            ;;
        esac

        # remove versioning
        providersdeps[$i]="${providersdeps[$i]%%[><=]*}"

        # list providers
        providers=($(expac -Ss '%n' "^${providersdeps[$i]}$" | sort -u))

        # filter out non matching versioned providers
        [[ "${providersdepsnover[*]}" ]] && providers=($(CommArr 'providersdepsnover' 'providers' '-12'))

        # skip if provided in dependency chain
        repodepspkgsprovided=0
        for j in "${!providers[@]}"; do
            [[ " ${repodepspkgs[*]} " = *" ${providers[$j]} "* ]] && repodepspkgsprovided=1
        done
        ((repodepspkgsprovided)) && continue

        # skip if already provided
        if [[ "${providerspkgs[*]}" ]]; then
            providerspkgs=($(printf '%s|' "${providerspkgs[@]}"))
            providerspkgs=("${providerspkgs[@]%|}")
            provided+=($(expac -Ss '%S' "^(${providerspkgs[*]})$"))
            [[ " ${provided[*]} " = *" ${providersdeps[$i]} "* ]] && continue
        fi

        if ((! noconfirm && "${#providers[*]}" > 1)); then
            info $"%sThere are %s providers available for %s:%s" "${colorW}" "${#providers[@]}" "${providersdeps[$i]}" "${reset}"
            expac -S1 '   %!) %n (%r) ' "${providers[@]}"
            nb='-1'
            providersnb="$(("${#providers[@]}" - 1))" # count from 0
            while ((nb < 0 || nb >= "${#providers}")); do
                printf "\n%s " $"Enter a number (default=0):"
                case "$TERM" in
                    dumb)
                    read -r nb
                    ;;
                    *)
                    read -r -n "${#providersnb}" nb
                    printf '\n'
                    ;;
                esac

                case "$nb" in
                    [0-9]|[0-9][0-9]) if ((nb < 0 || nb >= "${#providers[@]}")); then
                            printf '\n'
                            fail $"invalid value: %s is not between 0 and %s" "$nb" "$providersnb" && ((i--))
                        else
                            break
                        fi;;
                    '') nb=0;;
                    *) fail $"invalid number: %s" "$nb";;
                esac
            done
        else
            nb=0
        fi
        providerspkgs+=("${providers[$nb]}")
    done

    # add selected providers to repo deps
    repodepspkgs+=("${providerspkgs[@]}")

    # store for installation
    repoprovidersconflictingpkgs+=("${providerspkgs[@]}")

    FindDepsRepoProvider "${providerspkgs[@]}"

    # get binary packages info
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepspkgs=($(expac -S1 '%n' "${repodepspkgs[@]}" | sort -u))
        repodepsSver=($(expac -S1 '%v' "${repodepspkgs[@]}"))
        repodepsQver=($(expac -Q '%v' "${repodepspkgs[@]}"))
        repodepsSrepo=($(expac -S1 '%r/%n' "${repodepspkgs[@]}"))
    fi
}

ConflictChecks() {
    local allQprovides allQconflicts Aprovides Aconflicts aurconflicts aurAconflicts Qrequires i j
    local k l repodepsprovides repodepsconflicts checkedrepodepsconflicts repodepsconflictsname
    local repodepsconflictsver localver repoconflictingpkgs
    # global deps depsAname aurdepspkgs aurconflictingpkgs aurconflictingpkgskeep aurconflictingpkgsrm
    # global depsQver repodepspkgs repoconflictingpkgskeep repoconflictingpkgsrm repoprovidersconflictingpkgs
    printf '%s\n' $"looking for inter-conflicts..."

    allQprovides=($(expac -Q '%n'))
    allQprovides+=($(expac -Q '%S')) # no versioning
    allQconflicts=($(expac -Q '%C'))

    # AUR conflicts
    Aprovides=("${depsAname[@]}")
    Aprovides+=($(GetInfo "Provides"))
    Aconflicts=($(GetInfo "Conflicts"))
    # remove AUR versioning
    Aprovides=("${Aprovides[@]%%[><=]*}")
    Aconflicts=("${Aconflicts[@]%%[><=]*}")
    aurconflicts=($(CommArr 'Aprovides' 'allQconflicts' '-12'))
    aurconflicts+=($(CommArr 'Aconflicts' 'allQprovides' '-12'))
    aurconflicts=($(printf '%s\n' "${aurconflicts[@]}" | sort -u))

    for i in "${aurconflicts[@]}"; do
        unset aurAconflicts
        [[ " ${depsAname[*]} " = *" $i "* ]] && aurAconflicts=("$i")
        for j in "${depsAname[@]}"; do
            [[ " $(GetInfo "Conflicts" "$j") " = *" $i "* ]] && aurAconflicts+=("$j")
        done

        for j in "${aurAconflicts[@]}"; do
            unset k Aprovides
            read -rd' ' < <(expac -Qs '%n %P' "^$i$") k
            ((! installpkg)) && [[ ! " ${aurdepspkgs[*]} " = *" $j "* ]] && continue # download only
            [[ "$j" = "$k" || ! "$k" ]] && continue # skip if reinstalling or if no conflict exists

            Aprovides=("$j")
            if ((! noconfirm)) && [[ ! " ${aurconflictingpkgs[*]} " = *" $k "* ]]; then
                if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                    aurconflictingpkgs+=("$j" "$k")
                    aurconflictingpkgskeep+=("$j")
                    aurconflictingpkgsrm+=("$k")
                    for l in "${!depsAname[@]}"; do
                        [[ " ${depsAname[l]} " = *"$k"* ]] && read -rd' ' < <(expac -Qs '%v' "^$k$") depsQver[$l]
                    done
                    Aprovides+=($(GetInfo "Provides" "$j"))
                    # remove AUR versioning
                    Aprovides=("${Aprovides[@]%%[><=]*}")
                    [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " = *" $k "* ]] && CheckRequires "$k"
                    break
                else
                    fail $"unresolvable package conflicts detected"
                    fail $"failed to prepare transaction (conflicting dependencies)"
                    if ((upgrade)); then
                        Qrequires=($(expac -Q '%N' "$i"))
                        error $"%s and %s are in conflict (required by %s)" "$j" "$k" "${Qrequires[*]}" "$E_INSTALL_DEPS_FAILED"
                    else
                        error $"%s and %s are in conflict" "$j" "$k" "$E_INSTALL_DEPS_FAILED"
                    fi
                fi
            fi
            Aprovides+=($(GetInfo "Provides" "$j"))
            # remove AUR versioning
            Aprovides=("${Aprovides[@]%%[><=]*}")
            [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " = *" $k "* ]] && CheckRequires "$k"
        done
    done

    NothingToDo "${deps[@]}"

    # repo conflicts
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepsprovides=("${repodepspkgs[@]}")
        repodepsprovides+=($(expac -S1 '%S' "${repodepspkgs[@]}")) # no versioning
        repodepsconflicts=($(expac -S1 '%H' "${repodepspkgs[@]}"))

        # versioning check
        unset checkedrepodepsconflicts
        for i in "${!repodepsconflicts[@]}"; do
            unset repodepsconflictsname repodepsconflictsver localver
            repodepsconflictsname="${repodepsconflicts[$i]%%[><=]*}"
            repodepsconflictsver="${repodepsconflicts[$i]##*[><=]}"
            local localver="$(expac -Q '%v' "$repodepsconflictsname")"
            local repodepsconflictsverdiff="$(vercmp "$repodepsconflictsver" "$localver")"

            if [[ "$localver" ]]; then
                case "${repodepsconflicts[$i]}" in
                    *">="*) ((repodepsconflictsverdiff >= 0)) && continue;;
                    *"<="*) ((repodepsconflictsverdiff <= 0)) && continue;;
                    *">"*)  ((repodepsconflictsverdiff > 0))  && continue;;
                    *"<"*)  ((repodepsconflictsverdiff < 0))  && continue;;
                    *"="*)  ((repodepsconflictsverdiff == 0)) && continue;;
                esac
                checkedrepodepsconflicts+=("$repodepsconflictsname")
            fi
        done

        repoconflicts+=($(CommArr 'repodepsprovides' 'allQconflicts' '-12'))
        repoconflicts+=($(CommArr 'checkedrepodepsconflicts' 'allQprovides' '-12'))
        repoconflicts=($(printf '%s\n' "${repoconflicts[@]}" | sort -u))
    fi

    for i in "${repoconflicts[@]}"; do
        unset Qprovides
        unset j && read -rd' ' < <(expac -Ss '%n %C %S' "^$i$") j
	    unset k && read -rd' ' < <(expac -Qs '%n %C %S' "^$i$") k
        [[ "$j" = "$k" || ! "$k" ]] && continue # skip when no conflict with repopkgs
        if ((! noconfirm)) && [[ ! " ${repoconflictingpkgs[*]} " = *" $k "* ]]; then
            if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                repoconflictingpkgs+=("$j" "$k")
                repoconflictingpkgskeep+=("$j")
                repoconflictingpkgsrm+=("$k")
                repoprovidersconflictingpkgs+=("$j")
                Qprovides=($(expac -Ss '%S' "^$k$"))
                [[ ! " ${Qprovides[*]} ${repoconflictingpkgsrm[*]} " = *" $k "* ]] && CheckRequires "$k"
                break
            else
                fail $"unresolvable package conflicts detected"
                fail $"failed to prepare transaction (conflicting dependencies)"
                if ((upgrade)); then
                    Qrequires=($(expac -Q '%N' "$i"))
                    error $"%s and %s are in conflict (required by %s)" "$j" "$k" "${Qrequires[*]}" "$E_INSTALL_DEPS_FAILED"
                else
                    error $"%s and %s are in conflict" "$j" "$k" "$E_INSTALL_DEPS_FAILED"
                fi
            fi
        fi
        Qprovides=($(expac -Ss '%S' "^$k$"))
        [[ ! " ${Qprovides[*]} " = *" $k "* ]] && CheckRequires "$k"
    done
}

ReinstallChecks() {
    local i depsAtmp
    # global aurpkgs aurdepspkgs deps aurconflictingpkgs depsAname depsQver depsAver depsAood depsAmain
    depsAtmp=("${depsAname[@]}")
    for i in "${!depsAtmp[@]}"; do
        [[ ! " ${aurpkgs[*]} " = *" ${depsAname[$i]} "* ]] ||
            [[ " ${aurconflictingpkgs[*]} " = *" ${depsAname[$i]} "* ]] && continue
        [[ ! "${depsQver[$i]}" || "${depsQver[$i]}" = '%' ]] ||
            [[ "$(vercmp "${depsAver[$i]}" "${depsQver[$i]}")" -gt 0 ]] && continue
        ((! installpkg)) && [[ ! " ${aurdepspkgs[*]} " = *" ${depsAname[$i]} "* ]] && continue
        if [[ "${depsAname[$i]}" =~ $vcs ]]; then
            warn $"%s latest revision -- fetching" "${colorW}${depsAname[$i]}${reset}"
        else
            if ((! needed)); then
                warn $"%s-%s is up to date -- reinstalling" "${colorW}${depsAname[$i]}" "${depsQver[$i]}${reset}"
            else
                warn $"%s-%s is up to date -- skipping" "${colorW}${depsAname[$i]}" "${depsQver[$i]}${reset}"
                mapfile -t < <(printf ' %s \n' "${deps[@]}") deps
                deps=($(printf '%s\n' "${deps[@]// ${depsAname[$i]} /}"))
                unset "depsAname[$i]" "depsQver[$i]" "depsAver[$i]" "depsAood[$i]" "depsAmain[$i]"
            fi
        fi
    done
    ((needed)) && depsAname=("${depsAname[@]}") && depsQver=("${depsQver[@]}") &&
        depsAver=("${depsAver[@]}") && depsAood=("${depsAood[@]}") && depsAmain=("${depsAmain[@]}")
    NothingToDo "${deps[@]}"
}

OutOfDateChecks() {
    local i
    # global depsAname depsAver depsAood
    for i in "${!depsAname[@]}"; do
        (("${depsAood[$i]}" > 0)) &&
            warn $"%s-%s has been flagged %sout of date%s on %s" "${colorW}${depsAname[$i]}" "${depsAver[$i]}${reset}" "${colorR}" "${reset}" "${colorY}$(printf '%(%c)T\n' "${depsAood[$i]}")${reset}"
    done
}

OrphanChecks() {
    local i
    # global depsAname depsAver depsAmain
    for i in "${!depsAname[@]}"; do
        [[ "${depsAmain[$i]}" = 'null' || ! "${depsAmain[$i]}" ]] &&
            warn $"%s-%s is %sorphaned%s in AUR" "${colorW}${depsAname[$i]}" "${depsAver[$i]}${reset}" "${colorR}" "${reset}"
    done
}

Prompt() {
    local i binaryksize sumk summ builtpkg cachedpkgs stroldver strnewver strsize depsver
    local repodepspkgsver strrepodlsize strrepoinsize strsumk strsumm lreposizelabel lreposize
    # global repodepspkgs repodepsSver depsAname depsAver depsArepo depsAcached lname lver lsize
    # global deps depsQver repodepspkgs repodepsSrepo repodepsQver repodepsSver
    # compute binary size
    if [[ "${repodepspkgs[*]}" ]]; then
        binaryksize=($(expac -S1 '%k' "${repodepspkgs[@]}"))
        binarymsize=($(expac -S1 '%m' "${repodepspkgs[@]}"))
        sumk=0
        summ=0
        for i in "${!repodepspkgs[@]}"; do
            GetBuiltPkg "${repodepspkgs[$i]}-${repodepsSver[$i]}" "$(pacman-conf CacheDir)"
            [[ "$builtpkg" ]] && binaryksize[$i]=0
            sumk="$((sumk + "${binaryksize[$i]}"))"
            summ="$((summ + "${binarymsize[$i]}"))"
        done
        sumk="$((sumk / 1048576)).$((sumk / 1024 % 1024 * 100 / 1024))"
        summ="$((summ / 1048576)).$((summ / 1024 % 1024 * 100 / 1024))"
    fi

    # cached packages check
    for i in "${!depsAname[@]}"; do
        [[ ! "$PKGDEST" ]] || ((rebuild)) && break
        GetBuiltPkg "${depsAname[$i]}-${depsAver[$i]}" "$PKGDEST"
        [[ "$builtpkg" ]] && cachedpkgs+=("${depsAname[$i]}") && depsAcached[$i]=$"(cached)" || depsAcached[$i]=""
        unset builtpkg
    done

    if [[ "$(pacman-conf VerbosePkgLists)" ]]; then
        straurname=$"AUR Packages  (${#deps[@]})"; strreponame=$"Repo Packages (${#repodepspkgs[@]})"
        stroldver=$"Old Version"; strnewver=$"New Version"; strsize=$"Download Size"
        depsArepo=("${depsAname[@]/#/aur/}")
        lname="$(GetLength "${depsArepo[@]}" "${repodepsSrepo[@]}" "$straurname" "$strreponame")"
        lver="$(GetLength "${depsQver[@]}" "${depsAver[@]}" "${repodepsQver[@]}" "${repodepsSver[@]}" "$stroldver" "$strnewver")"
        lsize="$(GetLength "$strsize")"

        # local version column cleanup
        for i in "${!deps[@]}"; do
            [[ "${depsQver[$i]}" =~ '%' ]] && unset "depsQver[$i]"
        done
        # show detailed output
        printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s${reset}\n\n" \
            "$straurname" "$stroldver" "$strnewver"
        for i in "${!deps[@]}"; do
            printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" \
                "${depsArepo[$i]}" "${depsQver[$i]}" "${depsAver[$i]}" "${depsAcached[$i]}";
        done

        if [[ "${repodepspkgs[*]}" ]]; then
            for i in "${!repodepspkgs[@]}"; do
                binarysize[$i]="$((binaryksize[$i] / 1048576)).$((binaryksize[$i] / 1024 % 1024 * 100 / 1024))"
            done
            printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s  %s${reset}\n\n" \
                "$strreponame" "$stroldver" "$strnewver" "$strsize"
            for i in "${!repodepspkgs[@]}"; do
                printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" \
                    "${repodepsSrepo[$i]}" "${repodepsQver[$i]}" "${repodepsSver[$i]}" $"${binarysize[$i]} MiB";
            done
        fi
    else
        # show version
        for i in "${!deps[@]}"; do
            depsver="${depsver-}${depsAname[$i]}-${depsAver[$i]}  "
        done
        for i in "${!repodepspkgs[@]}"; do
            repodepspkgsver="${repodepspkgsver-}${repodepspkgs[$i]}-${repodepsSver[$i]}  "
        done
        printf "\n${colorW}%-16s${reset} %s\n" $"AUR Packages  (${#deps[@]})" "$depsver"
        [[ "${repodepspkgs[*]}" ]] &&
            printf "${colorW}%-16s${reset} %s\n" $"Repo Packages (${#repodepspkgs[@]})" "$repodepspkgsver"
    fi

    if [[ "${repodepspkgs[*]}" ]]; then
        strrepodlsize=$"Repo Download Size:"; strrepoinsize=$"Repo Installed Size:"; strsumk=$"$sumk MiB"
        strsumm=$"$summ MiB" lreposizelabel="$(GetLength "$strrepodlsize" "$strrepoinsize")"
        lreposize="$(GetLength "$strsumk" "$strsumm")"
        printf "\n${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "$strrepodlsize" "$strsumk"
        printf "${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "$strrepoinsize" "$strsumm"
    fi

    printf '\n'
    if ((installpkg)); then
        Proceed "y" $"Proceed with installation?" || exit "$E_FAIL"
    else
        Proceed "y" $"Proceed with download?" || exit "$E_FAIL"
    fi
}

DownloadPkgs() {
    local i
    # global basepkgs
    info $"%sRetrieving package(s)...%s" "${colorW}" "${reset}"
    GetPkgbase "$@"

    # no results check
    [[ ! "${basepkgs[*]}" ]] && error $"no results found" "$E_INSTALL_DEPS_FAILED"

    # reset
    for i in "${basepkgs[@]}"; do
        if [[ -d "$clonedir/$i" ]]; then
            git -C "$clonedir/$i" reset --hard HEAD -q # updated pkgver of vcs packages block pull
            [[ "$displaybuildfiles" = diff ]] &&
                git -C "$clonedir/$i" rev-parse HEAD > "$clonedir/$i/.git/HEAD.prev"
        fi
    done

    # clone
    auracle -C "$clonedir" clone "$@" >/dev/null ||
        error $"failed to retrieve packages" "$E_INSTALL_DEPS_FAILED"
}

EditPkgs() {
    local viewed=0 i j erreditpkg prev
    # global cachedpkgs installscripts editor
    ((noedit)) && return
    for i in "$@"; do
        [[ " ${cachedpkgs[*]} " = *" $i "* ]] && continue
        GetInstallScripts "$i"
        if ((! pace)); then
            if [[ "$displaybuildfiles" = diff && -e "$clonedir/$i/.git/HEAD.prev" ]]; then
                prev="$(<"$clonedir/$i/.git/HEAD.prev")"
                # show diff
                if git -C "$clonedir/$i" diff --quiet --no-ext-diff "$prev" -- . ':!\.SRCINFO'; then
                    warn $"%s build files are up-to-date -- skipping" "${colorW}$i${reset}"
                else
                    if Proceed "y" $"View $i build files diff?"; then
                        git -C "$clonedir/$i" diff --no-ext-diff "$prev" -- . ':!\.SRCINFO' ||
                            erreditpkg+=("$i")
                        info $"%s build files diff viewed" "${colorW}$i${reset}"; viewed=1
                    fi
                fi
            elif [[ ! "$displaybuildfiles" = none ]]; then
                # show pkgbuild
                if Proceed "y" $"View $i PKGBUILD?"; then
                    if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                        "$editor" "$clonedir/$i/PKGBUILD" &&
                            info $"%s PKGBUILD viewed" "${colorW}$i${reset}" || erreditpkg+=("$i")
                    else
                        error $"Could not open %s PKGBUILD" "${colorW}$i${reset}" "$E_MISSING_FILE"
                    fi
                fi
                # show install script
                if [[ "${installscripts[*]}" ]]; then
                    for j in "${installscripts[@]}"; do
                        if Proceed "y" $"View $j script?"; then
                            if [[ -e "$clonedir/$i/$j" ]]; then
                                "$editor" "$clonedir/$i/$j" &&
                                    info $"%s script viewed" "${colorW}$j${reset}" ||
                                    erreditpkg+=("$i")
                            else
                                error $"Could not open %s script" "${colorW}$j${reset}" "$E_MISSING_FILE"
                            fi
                        fi
                    done
                fi
            fi
        else
            # show pkgbuild and install script
            if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                "$editor" "$clonedir/$i/PKGBUILD" &&
                    info $"%s PKGBUILD viewed" "${colorW}$i${reset}" || erreditpkg+=("$i")
            else
                error $"Could not open %s PKGBUILD" "${colorW}$i${reset}" "$E_MISSING_FILE"
            fi
            if [[ "${installscripts[*]}" ]]; then
                for j in "${installscripts[@]}"; do
                    if [[ -e "$clonedir/$i/$j" ]]; then
                        "$editor" "$clonedir/$i/$j" &&
                            info $"%s script viewed" "${colorW}$j${reset}" || erreditpkg+=("$i")
                    else
                        error $"Could not open %s script" "${colorW}$j${reset}" "$E_MISSING_FILE"
                    fi
                done
            fi
        fi
    done

    if [[ "${erreditpkg[*]}" ]]; then
        for i in "${erreditpkg[@]}"; do
            fail $"%s errored on exit" "${colorW}$i${reset}"
        done
        exit "$E_FAIL"
    fi

    if [[ "$displaybuildfiles" = diff ]] && ((viewed)); then
        if ((installpkg)); then
            Proceed "y" $"Proceed with installation?" || exit
        else
            Proceed "y" $"Proceed with download?" || exit
        fi
    fi
}

MakePkgs() {
    local i j k oldorphanpkgs neworphanpkgs orphanpkgs oldoptionalpkgs newoptionalpkgs optionalpkgs
    local errinstall pkgsdepslist vcsclients vcschecked aurpkgsAver aurpkgsQver
    local builtpkgs builtdepspkgs basepkgsupdate checkpkgsdepslist deplist isaurdeps makedeps
    # global deps basepkgs sudoloop pkgsbase pkgsdeps aurpkgs aurdepspkgs builtpkg errmakepkg
    # global repoprovidersconflictingpkgs

    # download
    DownloadPkgs "${deps[@]}"
    EditPkgs "${basepkgs[@]}"

    # current orphan and optional packages
    oldorphanpkgs=($("$pacmanbin" -Qdtq))
    oldoptionalpkgs=($("$pacmanbin" -Qdttq))
    oldoptionalpkgs=($(CommArr 'oldorphanpkgs' 'oldoptionalpkgs' '-13'))

    # initialize sudo
    if sudo -n "$pacmanbin" -V > /dev/null || sudo -v; then
        [[ "$sudoloop" = true ]] && SudoV &
    fi

    # split packages support
    for i in "${!pkgsbase[@]}"; do
        for j in "${!deps[@]}"; do
            [[ "${pkgsbase[$i]}" = "${pkgsbase[$j]}" && ! " ${pkgsdeps[*]} " = *" ${deps[$j]} "* ]] &&
                pkgsdeps+=("${deps[$j]}")
        done
        pkgsdeps+=("%")
    done
    deplist="${pkgsdeps[*]}"; deplist="${deplist// % /|}"; deplist="${deplist//%}"
    deplist="${deplist// /,}"; deplist="${deplist//|/ }"; deplist="${deplist%, }"
    pkgsdeps=($(printf '%s\n' ${deplist% ,})); pkgsdeps=("${pkgsdeps[@]%,}")

    # reverse deps order
    for i in "${!basepkgs[@]}"; do
        basepkgsrev[$i]="${basepkgs[-i-1]}"
    done
    basepkgs=("${basepkgsrev[@]}") && unset basepkgsrev
    for i in "${!pkgsdeps[@]}"; do
        pkgsdepsrev[$i]="${pkgsdeps[-i-1]}"
    done
    pkgsdeps=("${pkgsdepsrev[@]}") && unset pkgsdepsrev

    # integrity check
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        read -rd',' -a pkgsdepslist <<< "${pkgsdeps[$i]}"

        # cache check
        unset builtpkg
        if [[ ! "${basepkgs[$i]}" =~ $vcs ]]; then
            for j in "${pkgsdepslist[@]}"; do
                [[ "$PKGDEST" ]] && ((! rebuild)) && GetBuiltPkg "$j-$(GetInfo "Version" "$j")" "$PKGDEST"
            done
        fi

        # install vcs clients (checking pkgbase extension only does not take fetching specific
        # commit into account)
        unset vcsclients
        makedeps=($(GetInfo "MakeDepends" "${basepkgs[$i]}"))
        for k in git subversion mercurial bzr cvs darcsl; do
            [[ " ${makedeps[*]} " = *" $k "* ]] && vcsclients+=("$k")
        done
        unset makedeps
        for j in "${vcsclients[@]}"; do
            if [[ ! " ${vcschecked[*]} " = *" $j "* ]]; then
                expac -Qs '' "^$j$" || sudo "$pacmanbin" -S --asdeps --noconfirm -- "$j"
                vcschecked+=("$j")
            fi
        done

        if [[ ! "${builtpkg-}" ]] || ((rebuild)); then
            cd "${clonedir:?}/${basepkgs[$i]}" || exit "$E_MISSING_FILE"
            info $"Checking %s integrity..." "${colorW}${pkgsdeps[$i]}${reset}"
            if [[ "$silent" = true ]]; then
                makepkg -f --verifysource "${makeopts[@]}" &>/dev/null
            else
                makepkg -f --verifysource "${makeopts[@]}" >/dev/null
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
            # extraction, prepare and pkgver update
            info $"Preparing %s..." "${colorW}${pkgsdeps[$i]}${reset}"
            if [[ "$silent" = true ]]; then
                makepkg -od --skipinteg "${makeopts[@]}" &>/dev/null
            else
                makepkg -od --skipinteg "${makeopts[@]}"
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
        fi
    done
    if [[ "${errmakepkg[*]}" || "${errinstall[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            fail $"failed to verify integrity or prepare %s package" "${colorW}$i${reset}"
        done
        # remove sudo lock
        rm -f "${tmpdir:?}/pacaur.sudov.lck"
        exit "$E_FAIL"
    fi

    # check database lock
    [[ -e "/var/lib/pacman/db.lck" ]] && error $"db.lck exists in /var/lib/pacman" "$E_FAIL"

    # set build lock
    [[ -e "$tmpdir/pacaur.build.lck" ]] && error $"pacaur.build.lck exists in %s" "$tmpdir" "$E_FAIL"
    : > "$tmpdir/pacaur.build.lck"

    # install provider packages and repo conflicting packages that makepkg --noconfirm cannot handle
    if [[ "${repoprovidersconflictingpkgs[*]}" ]]; then
        info $"Installing %s dependencies..." "${colorW}${repoprovidersconflictingpkgs[@]}${reset}"
        sudo "$pacmanbin" -S "${repoprovidersconflictingpkgs[@]}" --ask 36 --asdeps --noconfirm
    fi

    # main
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        read -rd',' -a pkgsdepslist <<< "${pkgsdeps[$i]}"

        cd "$clonedir/${basepkgs[$i]}" || exit "$E_MISSING_FILE"
        # retrieve updated version
        mapfile -d'-' -t < <(makepkg --packagelist) k && aurpkgsAver="${k[-3]}-${k[-2]}"; unset k
        # build devel if necessary only (supported protocols only)
        if [[ "${basepkgs[$i]}" =~ $vcs ]]; then
            # check split packages update
            unset basepkgsupdate checkpkgsdepslist
            for j in "${pkgsdepslist[@]}"; do
                read -rd' ' < <(expac -Qs '%v' "^$j$") aurpkgsQver
                if ((needed && ! rebuild)) &&
                    [[ "$aurpkgsQver" && "$(vercmp "$aurpkgsQver" "$aurpkgsAver")" -ge 0 ]]; then
                    warn $"%s is up-to-date -- skipping" "${colorW}$j${reset}" && continue
                else
                    basepkgsupdate='true'; checkpkgsdepslist+=("$j")
                fi
            done
            [[ "$basepkgsupdate" ]] && pkgsdepslist=("${checkpkgsdepslist[@]}") || continue
        fi

        # check package cache
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            [[ "$PKGDEST" ]] && ((! rebuild)) && GetBuiltPkg "$j-$aurpkgsAver" "$PKGDEST"
            if [[ "$builtpkg" ]]; then
                if [[ " ${aurdepspkgs[*]} " = *" $j "* ]] || ((installpkg)); then
                    info $"Installing %s cached package..." "${colorW}$j${reset}"
                    sudo "$pacmanbin" -U --ask 36 "${pacopts[@]/--quiet}" --noconfirm -- "$builtpkg"
                    [[ " ${aurpkgs[*]} " = *" $j "* ]] ||
                        sudo "$pacmanbin" -D "$j" --asdeps "${pacopts[@]}" &>/dev/null
                else
                    warn $"Package %s already available in cache" "${colorW}$j${reset}"
                fi
                pkgsdeps=("${pkgsdeps[@]/#$j,}"); pkgsdeps=("${pkgsdeps[@]/%,$j}")
                pkgsdeps=("${pkgsdeps[@]//,$j,/,}")
                for k in "${!pkgsdeps[@]}"; do
                    [[ "${pkgsdeps[k]}" = "$j" ]] && pkgsdeps[k]='%'
                done
                continue
            fi
        done
        [[ "${pkgsdeps[$i]}" = '%' ]] && continue

        # build
        info $"Building %s package(s)..." "${colorW}${pkgsdeps[$i]}${reset}"

        # install then remove binary deps
        makeopts=("${makeopts[@]/-r/}")

        if ((! installpkg)); then
            isaurdeps=0
            for j in "${pkgsdepslist[@]}"; do
                [[ " ${aurdepspkgs[*]} " = *" $j "* ]] && isaurdeps=1
            done
            ((isaurdeps)) && makeopts+=('-r')
        fi

        if [[ "$silent" = true ]]; then
            makepkg -sefc "${makeopts[@]}" --noconfirm &>/dev/null
        else
            makepkg -sefc "${makeopts[@]}" --noconfirm
        fi

        # error check
        (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}") && continue # skip install

        # retrieve filename
        unset builtpkgs builtdepspkgs
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            if [[ "$PKGDEST" ]]; then
                GetBuiltPkg "$j-$aurpkgsAver" "$PKGDEST"
            else
                GetBuiltPkg "$j-$aurpkgsAver" "${clonedir:?}/${basepkgs[$i]}"
            fi
            [[ " ${aurdepspkgs[*]} " = *" $j "* ]] && builtdepspkgs+=("$builtpkg") || builtpkgs+=("$builtpkg")
        done

        # install
        if ((installpkg)) || [[ ! "${builtpkgs[*]}" ]]; then
            info $"Installing %s package(s)..." "${colorW}${pkgsdeps[$i]}${reset}"
            sudo "$pacmanbin" -U ${builtdepspkgs[@]} ${builtpkgs[@]} --ask 36 "${pacopts[@]/--quiet}" --noconfirm
        fi

        # set dep status
        if ((installpkg)); then
            for j in "${pkgsdepslist[@]}"; do
                [[ ! " ${aurpkgs[*]} " = *" $j "* ]] && sudo "$pacmanbin" -D "$j" --asdeps &>/dev/null
                ((asdeps)) && sudo "$pacmanbin" -D "$j" --asdeps &>/dev/null
                ((asexplicit)) && sudo "$pacmanbin" -D "$j" --asexplicit &>/dev/null
            done
        fi
    done

    # remove AUR deps
    if ((! installpkg)); then
        [[ "${aurdepspkgs[*]}" ]] && aurdepspkgs=($(expac -Q '%n' "${aurdepspkgs[@]}"))
        [[ "${aurdepspkgs[*]}" ]] && info $"Removing installed AUR dependencies..." &&
            sudo "$pacmanbin" -Rsn "${aurdepspkgs[@]}" --noconfirm
        # re-add removed conflicting packages
        [[ "${aurconflictingpkgsrm[*]}" ]] &&
            sudo "$pacmanbin" -S "${aurconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
        [[ "${repoconflictingpkgsrm[*]}" ]] &&
            sudo "$pacmanbin" -S "${repoconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
    fi

    # remove locks
    rm "${tmpdir:?}/pacaur.build.lck"
    rm -f "${tmpdir:?}/pacaur.sudov.lck"

    # new orphan and optional packages check
    orphanpkgs=($("$pacmanbin" -Qdtq))
    neworphanpkgs=($(CommArr 'oldorphanpkgs' 'orphanpkgs' '-13'))
    for i in "${neworphanpkgs[@]}"; do
        warn $"%s is now an %sorphan%s package" "${colorW}$i${reset}" "${colorY}" "${reset}"
    done
    optionalpkgs=($("$pacmanbin" -Qdttq))
    optionalpkgs=($(CommArr 'orphanpkgs' 'optionalpkgs' '-13'))
    newoptionalpkgs=($(CommArr 'oldoptionalpkgs' 'optionalpkgs' '-13'))
    for i in "${newoptionalpkgs[@]}"; do
        warn $"%s is now an %soptional%s package" "${colorW}$i${reset}" "${colorY}" "${reset}"
    done

    # makepkg and install failure check
    if [[ "${errmakepkg[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            fail $"failed to build %s package(s)" "${colorW}$i${reset}"
        done
        exit "$E_PACKAGE_FAILED"
    fi
    [[ "${errinstall[*]}" ]] && exit  "$E_INSTALL_FAILED"
}

CleanCache() {
    local i cachepkgs
    cachedir=($(pacman-conf CacheDir))
    [[ "${cachedir[*]}" ]] && cachedir=("${cachedir[@]%/}") && PKGDEST="${PKGDEST%/}"
    if [[ "$PKGDEST" && ! " ${cachedir[*]} " = *" $PKGDEST "* ]]; then
        ((ccount == 1)) && printf "\n%s\n %s\n" $"Packages to keep:" $"All locally installed packages"
        printf "\n%s %s\n" $"AUR cache directory:" "$PKGDEST"
        if ((ccount == 1)); then
            if Proceed "y" $"Do you want to remove all other packages from AUR cache?"; then
                printf "%s\n" $"removing old packages from cache..."
                cachepkgs=("${PKGDEST:?}"/*); cachepkgs=("${cachepkgs[@]##*/}")
                for i in "${cachepkgs[@]%-*}"; do
                    [[ "$i" != "$(expac -Q '%n-%v' "${i%-*-*}")" ]] && rm "${PKGDEST:?}/$i"-*
                done
            fi
        else
            Proceed "n" $"Do you want to remove ALL files from AUR cache?" ||
                printf "%s\n" $"removing all files from AUR cache..." &&
                rm "${PKGDEST:?}"/* &>/dev/null
        fi
    fi

    if [[ -d "$SRCDEST" ]]; then
        ((ccount == 1)) &&
            printf "\n%s\n %s\n" $"Sources to keep:" $"All development packages sources"
        printf "\n%s %s\n" $"AUR source cache directory:" "$SRCDEST"
        if ((ccount == 1)); then
            Proceed "y" $"Do you want to remove all non development files from AUR source cache?" &&
                printf "%s\n" $"removing non development files from source cache..." &&
                rm -f "${SRCDEST:?}"/* &>/dev/null
        else
            Proceed "n" $"Do you want to remove ALL files from AUR source cache?" ||
                printf "%s\n" $"removing all files from AUR source cache..." &&
                rm -rf "${SRCDEST:?}"/*
        fi
    fi
    if [[ -d "$clonedir" ]]; then
        if ((ccount == 1)); then
            if [[ ! "${pkgs[*]}" ]]; then
                printf "\n%s\n %s\n" $"Clones to keep:" $"All locally installed clones"
            else
                printf "\n%s\n %s\n" $"Clones to keep:" $"All other locally installed clones"
            fi
        fi
        printf "\n%s %s\n" $"AUR clone directory:" "$clonedir"
        if ((ccount == 1)); then
            mapfile -t < <(expac -Q '%e' $("$pacmanbin" -Qmq)) foreignpkgsbase
            # get target
            if [[ "${pkgs[*]}" ]]; then
                mapfile -t < <(expac -Q '%e' "${pkgs[@]}") pkgsbase
                mapfile -t < <(CommArr 'pkgsbase' 'foreignpkgsbase' '-12') aurpkgsbase
                if Proceed "y" $"Do you want to remove ${aurpkgsbase[*]} clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${aurpkgsbase[@]}"; do
                        [[ -d "$clonedir/$i" ]] && rm -rf "${clonedir:?}/$i"
                    done
                fi
            else
                if Proceed "y" $"Do you want to remove all uninstalled clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${clonedir:?}/"*; do
                        [[ -d "$i" && ! " ${foreignpkgsbase[*]} " = *" $i "* ]] &&
                            rm -rf "${clonedir:?}/$i"
                    done
                fi
                if [[ ! "$PKGDEST" || ! "$SRCDEST" ]]; then
                    if Proceed "y" $"Do you want to remove all untracked files from AUR clone directory?"; then
                        printf "%s\n" $"removing untracked files from AUR clone cache..."
                        for i in "${clonedir:?}/"*; do
                            [[ -d "$i" ]] &&
                                git --git-dir="$i/.git" --work-tree="$i" clean -ffdx &>/dev/null
                        done
                    fi
                fi
            fi
        else
            if ! Proceed "n" $"Do you want to remove ALL clones from AUR clone directory?"; then
                printf "%s\n" $"removing all clones from AUR clone cache..."
                for i in "${clonedir:?}/"*; do
                    [[ -d "$i" ]] && rm -rf "$i"
                done
            fi
        fi
    fi
    exit "$E_OK"
}

GetIgnoredPkgs() {
    # global ignoredpkgs
    ignoredpkgs+=($(pacman-conf IgnorePkg))
    ignoredpkgs=("${ignoredpkgs[@]//,/ }")
}

GetIgnoredGrps() {
    # global ignoredgrps
    ignoredgrps+=($(pacman-conf IgnoreGroup))
    ignoredgrps=("${ignoredgrps[@]//,/ }")
}

GetInstallScripts() {
    local installscriptspath
    # global installscripts
    [[ ! -d "$clonedir/$1" ]] && return
    unset installscriptspath installscripts
    shopt -s nullglob
    installscriptspath=($(printf '%s\n' "$clonedir/$1/"*'.install'))
    shopt -u nullglob
    [[ "${installscriptspath[*]}" ]] && installscripts=("${installscriptspath[@]##*/}")
}

GetBuiltPkg() {
    local ext
    # global builtpkg
    # check PKGEXT suffix first, then default .xz suffix for repository packages in pacman cache
    # and lastly all remaining suffixes in case PKGEXT is locally overridden
    for ext in "$PKGEXT" .pkg.tar{.xz,,.gz,.bz2,.lzo,.lrz,.Z}; do
        builtpkg="$2/$1-${CARCH}${ext}"
        [[ -f "$builtpkg" ]] || builtpkg="$2/$1-any${ext}"
        [[ -f "$builtpkg" ]] && break
    done
    [[ -f "$builtpkg" ]] || unset builtpkg
}

GetPkgbase() {
    local i
    # global pkgsbase basepkgs
    SetInfo "$@"
    for i in "$@"; do
        pkgsbase+=($(GetInfo "PackageBase" "$i"))
    done
    for i in "${pkgsbase[@]}"; do
        [[ " ${basepkgs[*]} " = *" $i "* ]] || basepkgs+=("$i")
    done
}

SetInfo() {
    # Usage: SetInfo $@
    # Use auracle formatted info output for all aur packages passed to SetInfo, and sort it into
    # associated arrays
    local fields=(Name PackageBase Version Maintainer OutOfDate Groups {,Make,Check}Depends Provides Conflicts)
    local auracle_packages=("$@") cache_array=() info_arrays=() i j

    # cache previous info arrays in temporary arrays of the same names, but prefixed with c
    if [[ "${Name[*]}" ]]; then
        mapfile -t cache_array < <(declare -p "${fields[@]}")
        local -A "${cache_array[@]/#declare -A /c}"
    fi

    unset "${fields[@]}"
    [[ "$*" ]] || return
    declare -Ag "${fields[@]}"

    for i in "${!cName[@]}"; do
        if [[ " $* " = *" ${cName[$i]} "* ]]; then
            for j in "${!auracle_packages[@]}"; do
                [[ "${cName[$i]}" != "${auracle_packages[j]}" ]] || unset "auracle_packages[$j]"
            done
            Name[$i]="${cName[$i]}"
            PackageBase[$i]="${cPackageBase[$i]}"
            Version[$i]="${cVersion[$i]}"
            Maintainer[$i]="${cMaintainer[$i]}"
            OutOfDate[$i]="${cOutOfDate[$i]}"
            Groups[$i]="${cGroups[$i]}"
            Depends[$i]="${cDepends[$i]}"
            MakeDepends[$i]="${cMakeDepends[$i]}"
            CheckDepends[$i]="${cCheckDepends[$i]}"
            Provides[$i]="${cProvides[$i]}"
            Conflicts[$i]="${cConflicts[$i]}"
        fi
    done

    if [[ "${auracle_packages[*]}" ]]; then
        mapfile -t info_arrays < <(auracle info "${auracle_packages[@]}" -F \
            $'Name[{name}]={name}\nPackageBase[{name}]={pkgbase}\nVersion[{name}]={version}\nMaintainer[{name}]={maintainer}\nOutOfDate[{name}]={outofdate:%s}\nGroups[{name}]={groups:\037}\nDepends[{name}]={depends:\037}\nMakeDepends[{name}]={makedepends:\037}\nCheckDepends[{name}]={checkdepends:\037}\nProvides[{name}]={provides:\037}\nConflicts[{name}]={conflicts:\037}')
        [[ ! "${info_arrays[*]}" ]] || declare -g "${info_arrays[@]}"
   fi
}

GetInfo() {
    local -n field="$1"

    if [[ "$2" ]]; then
        printf '%s\n' "${field[$2]//$'\037'/ }"
    else
        printf '%s\n' "${field[@]//$'\037'/ }"
    fi
}

CheckRequires() {
    local -a Qrequires
    mapfile -t Qrequires < <(expac -Q '%N' "$@")
    if [[ "${Qrequires[*]}" ]]; then
        fail $"failed to prepare transaction (could not satisfy dependencies)"
        error $"%s: requires %s" "${Qrequires[*]}" "$*" "$E_INSTALL_DEPS_FAILED"
    fi
}

Proceed() {
    local answer ret readline=0

    if [[ "$TERM" = dumb ]] || ((cleancache)); then
        readline=1
    fi
    case "$1" in
        y)  printf "%s %s" "${colorB}::${reset}" "${colorW}$2 [Y/n] ${reset}"
            if ((noconfirm)); then
                printf '\n'
                return 0
            fi
            while true; do
                if ((readline)); then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Yy]|'') ret=0; break;;
                    [Nn]) ret=1; break;;
                    *) ((readline)) && ret=1 && break;;
                esac
            done;;
        n)  printf "%s %s" "${colorB}::${reset}" "${colorW}$2 [y/N] ${reset}"
            if ((noconfirm)); then
                printf '\n'
                return 0
            fi
            while true; do
                if ((readline)); then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Nn]|'') ret=0; break;;
                    [Yy]) ret=1; break;;
                    *) ((readline)) && ret=0 && break;;
                esac
            done;;
    esac
    ((! readline)) && printf '%s\n' "$answer"
    return "$ret"
}

info() {
    printf "%s::%s $1\n" "${colorB}" "${reset}" "${@:2}"
}

warn() {
    printf "%swarning:%s $1\n" "${colorY}" "${reset}" "${@:2}" >&2
}

fail() {
    printf "%serror:%s $1\n" "${colorR}" "${reset}" "${@:2}" >&2
}

error() {
    printf "%serror:%s $1\n" "${colorR}" "${reset}" "${@:2:$(($# - 2))}" >&2
    exit "${!#}"
}

GetLength() {
    local length=0 i
    for i in "$@"; do
        x="${#i}"
        ((x > length)) && length="$x"
    done
    printf '%s\n' "$length"
}

NothingToDo() {
    [[ ! "$*" ]] && printf '%s\n' $" there is nothing to do" && exit "$E_OK" || return 0
}

SudoV() {
    : > "$tmpdir/pacaur.sudov.lck"
    while [[ -e "$tmpdir/pacaur.sudov.lck" ]]; do
        sudo "$pacmanbin" -V > /dev/null
        sleep 298
    done
}

CommArr() {
    # args are names of 2 arrays and outputs elements that are only in the 2nd
    local array1="$1[@]" array2="$2[@]"
    comm <(sort -u <(printf '%s\n' "${!array1-}")) <(sort -u <(printf '%s\n' "${!array2-}")) "$3"
}

trap Cancel INT
Cancel() {
    printf '\n'
    rm -f "${tmpdir:?}"/pacaur.{build,sudov}.lck
    exit
}

Usage() {
    printf '%s\n' $"usage:  pacaur <operation> [options] [target(s)] -- See also pacaur(8)"
    printf '%s\n' $"operations:"
    printf '%s\n' $" pacman extension"
    printf '%s\n' $"   -S, -Ss, -Si, -Sw, -Su, -Qu, -Sc, -Scc"
    printf '%s\n' $"                    extend pacman operations to the AUR"
    printf '%s\n' $" general"
    printf '%s\n' $"   -v, --version    display version information"
    printf '%s\n' $"   -h, --help       display help information"
    printf '\n'
    printf '%s\n' $"options:"
    printf '%s\n' $" pacman extension - can be used with the -S, -Ss, -Si, -Sw, -Su, -Sc, -Scc operations"
    printf '%s\n' $"   -a, --aur        only search, build, install or clean target(s) from the AUR"
    printf '%s\n' $"   -r, --repo       only search, build, install or clean target(s) from the repositories"
    printf '%s\n' $" general"
    printf '%s\n' $"   -e, --edit       edit target(s) PKGBUILD and view install script"
    printf '%s\n' $"   -q, --quiet      show less information for query and search"
    printf '%s\n' $"   --devel          consider AUR development packages upgrade"
    printf '%s\n' $"   --foreign        consider already installed foreign dependencies"
    printf '%s\n' $"   --ignore         ignore a package upgrade (can be used more than once)"
    printf '%s\n' $"   --needed         do not reinstall already up-to-date target(s)"
    printf '%s\n' $"   --noconfirm      do not prompt for any confirmation"
    printf '%s\n' $"   --noedit         do not prompt to edit files"
    printf '%s\n' $"   --rebuild        always rebuild package(s)"
    printf '%s\n' $"   --silent         silence output"
    exit "$E_OK"
}

#
# Main
#

# options
shortopts="DFQRSTUVacdefghiklmnopqrstuvwxy"
longopts=('help' 'database' 'files' 'query' 'remove' 'sync' 'deptest' 'upgrade')
longopts+=('asdeps' 'asexplicit' 'cascade' 'changelog' 'check' 'confirm' 'dbonly' 'debug' 'deps'
           'disable-download-timeout' 'downloadonly' 'explicit' 'file' 'foreign' 'groups' 'info'
           'list' 'machinereadable' 'native' 'needed' 'noconfirm' 'nodeps' 'noprogressbar' 'nosave'
           'noscriptlet' 'owns' 'print' 'recursive' 'refresh' 'regex' 'quiet' 'search' 'sysupgrade'
           'unneeded' 'unrequired' 'upgrades' 'verbose')
longopts+=('arch:' 'assume-installed:' 'cachedir:' 'color:' 'config:' 'dbpath:' 'gpgdir:' 'hookdir:'
           'ignore:' 'ignoregroup:' 'logfile:' 'overwrite:' 'print-format:' 'root:' 'sysroot:')
longopts_aur=('aur' 'by:' 'devel' 'edit' 'literal' 'noedit' 'rebuild' 'repo' 'rsort:' 'searchby:'
              'silent' 'sort:' 'update' 'version')
parseopts "${shortopts}" "${longopts[@]}" "${longopts_aur[@]}" -- "$@" || exit "$E_INVALID_OPTION"
set -- "${OPTRET[@]}"

while true; do
    [[ "$1" = -[cdf-qs-zDFQRSTUV] ]] && pacmanarg+=("$1")
    for i in "${longopts[@]}"; do
        [[ "$1" = "--$i" ]] && pacopts+=("$1")
        [[ "$1": = "--$i" ]] && pacopts+=("$1=$2")
    done
    case "$1" in
        -S|--sync) pacS=1; installpkg=1; operation=sync; ((++pac));;
        -Q|--query) pacQ=1; ((++pac));;
        -s|--search) search=1;;
        -i|--info) info=1;;
        -e|--edit) pace=1;;
        -u|--upgrades|--sysupgrade) upgrade=1; installpkg=1;;
        -q|--quiet) declare -x QUIET=1; auropts+=("$1");;
        -c|--clean) cleancache=1 && ((++ccount));;
        -n|--native) native=1;;
        -r|--repo) repo=1;;
        -a|--aur) aur=1;;
        --ignore) ignoredpkgs+=("$2"); shift;;
        --color) color="$2"; shift;;
        --literal) auropts+=("$1");;
        --@(by|searchby)) auropts+=("--searchby=$2"); shift;;
        --sort) sortorder="ascending"; sortby="$2"; shift;;
        --rsort) sortorder="descending"; sortby="$2"; shift;;
        -d|--nodeps) nodeps=1; makeopts+=("$1"); ((++dcount));;
        --assume-installed) assumeinstalled+=("$2"); shift;;
        -[DFRTUV]|--@(database|files|remove|deptest|upgrade)) ((++pac));;
        --@(asdeps|asexplicit|devel|needed|noconfirm|noedit|rebuild)) declare "${1/--}"=1;;
        -[glp]|--@(groups|list|print)) noop=1;;
        -w|--downloadonly) downloadonly=1;;
        --silent) silent=true; pacopts+=("--quiet"); auropts+=("--quiet") makeopts+=("--log");;
        -y|--refresh) refresh=1;;
        -h|--help) help=1;;
        --version) operation=version; ((++pac));;
        -v) ver=1;;
        --) shift; break;;
    esac
    shift
done

# help or version
[[ "$operation" = version ]] || ((! pac && ver)) && printf '%s\n' "pacaur $version" && exit "$E_OK"
((! pac && help)) && Usage

# sorting
case "$sortorder" in
    ascending)  auropts+=("--sort=$sortby");;
    descending) auropts+=("--rsort=$sortby");;
esac

# packages
pkgs=("$@")

# color
if [[ ! "$color" && (! "$(pacman-conf Color)" || "$operation" = upgrades || "$QUIET" && "$search") ]]; then
    color='never'
else
    color='auto'
fi
pacopts+=("--color=$color") auropts+=("--color=$color")
if [[ ! "$color" = never ]]; then
    reset=$'\e[0m' colorR=$'\e[1;31m' colorG=$'\e[1;32m' colorY=$'\e[1;33m'
    colorB=$'\e[1;34m' colorM=$'\e[1;35m' colorW=$'\e[1;39m'
else
    reset='' colorR='' colorG='' colorY='' colorB='' colorM='' colorW=''
    makeopts+=('--nocolor')
fi
declare -r reset colorR colorG colorY colorB colorM colorW

# sanity check
if ((aur)); then
    refresh=0
fi
if ((! pac && pace)); then
    operation=edit
fi
if ((pacQ && pace)); then
    pacopts+=('-e')
fi
if ((pacQ && upgrade)); then
    operation=upgrades
fi
if ((pacQ && native)); then
    repo=1
fi
if ((pacS && downloadonly)); then
    installpkg=0
fi
if ((pacS && noop)); then
    operation=''
fi
if ((pacS && cleancache)); then
    search=0 info=0 upgrade=0
fi
if ((pac > 1)); then
    error $"only one operation may be used at a time" "$E_FAIL"
fi
if [[ "$operation" = sync ]] && ((! search && ! info && ! cleancache && ! EUID)); then
    error $"you cannot perform this operation as root" "$E_ROOT"
fi
if ((pacS && search && info)); then
    error $"invalid option: '--info' and '--search' may not be used together" "$E_INVALID_OPTION"
fi
[[ "$(command -v "${editor%% *}")" ]] ||
    error $"%s\$VISUAL%s and %s\$EDITOR%s environment variables not set or defined %seditor%s not found" "${colorW}" "${reset}" "${colorW}" "${reset}" "${colorW}" "${reset}" "$E_MISSING_FILE"
if [[ "${PACMAN-}" = "${0##*/}" ]]; then
    error $"you cannot use %spacaur%s as PACMAN environment variable" "${colorW}" "${reset}" "$E_FAIL"
fi
[[ -w "$clonedir" ]] ||
    error $"%s does not have write permission" "${colorW}$clonedir${reset}" "$E_FS_PERMISSIONS"
if [[ ! "${pkgs[*]}" && "$operation" =~ (sync|edit) ]] && ((! help && ! refresh && ! upgrade && ! cleancache)); then
        error $"no targets specified (use -h for help)" "$E_FAIL"
fi
if [[ ! "${pkgs[*]}" && " ${pacmanarg[*]} " =~ ' '-[RU]' ' ]] && ((! help)); then
    error $"no targets specified (use -h for help)" "$E_FAIL"
fi
if ((repo && aur)); then
    aur=0 repo=0
    warn $"invalid option: '-r/--repo' and '-a/--aur' may not be used together, disabling both"
fi

# operations
case "$operation" in
    edit) # edit (-e) handling
        GetPkgbase "${pkgs[@]}"
        EditPkgs "${pkgsbase[@]}"
        exit;;
    sync)
        # search (-Ss, -s) handling
        if ((search)); then
            if ((! aur)); then
                if ((refresh)); then
                    sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
                else
                    "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
                fi
                exitrepo="$?"
            fi
            if ((! repo)); then
                auracle search "${auropts[@]}" -- ${pkgs[@]#aur/}; exitaur="$?"
            fi
            # exit code
            ((! exitrepo || ! exitaur)) && exit "$E_OK" || exit "$E_FAIL"
        # info (-Si, -i) handling
        elif ((info)); then
            if [[ ! "${pkgs[*]}" ]]; then
                "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}"
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                if ((refresh)); then
                    sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" "${repopkgs[@]}"
                else
                    "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" "${repopkgs[@]}"
                fi
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                if ((refresh)) && [[ ! "${repopkgs[*]}" ]]; then
                    sudo "$pacmanbin" -Sy "${pacopts[@]}"
                fi
                if ((! aur)); then
                    info $"Package(s) %s not found in repositories, trying %sAUR%s..." "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
                fi
                auracle info "${auropts[@]}" -- "${aurpkgs[@]}"
            fi
        # clean (-Sc) handling
        elif ((cleancache)); then
            if ((! aur)); then
                sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" ${repopkgs[@]}
            fi
            if ((! repo)); then
                CleanCache "${pkgs[@]}"
            fi
        # sysupgrade (-Su, -u) handling
        elif ((upgrade)); then
            [[ "${pkgs[*]}" ]] && ClassifyPkgs "${pkgs[@]}"
            if ((! aur)); then
                if ! sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" ${repopkgs[@]} && ((repo)); then
                    exit "$E_FAIL"
                fi
            fi
            if [[ "${aurpkgs[*]}" ]] && ((! aur)); then
                info $"Package(s) %s not found in repositories, trying %sAUR%s..." "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
            fi
            if ((! repo)); then
                Core
            fi
        elif ((help)); then
            "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
        # sync (-S, -y), downloadonly (-Sw, -m), refresh (-Sy)
        else
            if [[ ! "${pkgs[*]}" ]]; then
                sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}"
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" "${repopkgs[@]}"
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                if ((refresh)) && [[ ! "${repopkgs[*]}" ]]; then
                    sudo "$pacmanbin" -Sy "${pacopts[@]}"
                fi
                if ((! aur)); then
                    info $"Package(s) %s not found in repositories, trying %sAUR%s..." \
                        "${colorW}${aurpkgs[*]}${reset}" "${colorM}" "${reset}"
                fi
                Core
            fi
        fi
        exit;;
    upgrades) # upgrades (-Qu) handling
        if ((! aur)); then
            "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
        fi
        exitrepo="$?"
        if ((! repo)); then
            if [[ ! "${pkgs[*]}" ]]; then
                auracle sync "${auropts[@]}" $("$pacmanbin" -qm ${pacmanarg[@]//-u} "${pacopts[@]//--upgrades}")
            else
                auracle sync "${auropts[@]}" -- "${pkgs[@]}"
            fi
            exitaur="$?"
        fi
        if ((! exitrepo || ! exitaur)); then
            exit "$E_OK"
        else
            exit "$E_FAIL"
        fi;;
    *)  if [[ " ${pacmanarg[*]} " = *' -F '* ]] && ((refresh)); then
            sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
        elif [[ ! "${pkgs[*]}" || " ${pacmanarg[*]} " =~ ' '-[DFQTglp]' ' ]] &&
            ((! asdeps && ! asexplicit)); then
                "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
        else
            sudo "$pacmanbin" ${pacmanarg[@]} "${pacopts[@]}" -- ${pkgs[@]}
        fi
        exit;; # others operations handling
esac

# vim:set ts=4 sw=4 et:
