#!/bin/bash
#
# pacaur: an AUR helper that minimizes user interaction
#

shopt -s extglob
declare -r version="4.8.6"

#
# Config
#

# sanitize
unset aur asdeps asexplicit checkdeps cleancache ccount dcount devel downloadonly edit info
unset installpkg native needed noconfirm nodeps noedit noop operation pac pace pacQ pacS quiet
unset readline rebuild refresh repo search upgrade var vcs ver

# internationalization
export LC_COLLATE=C
export TEXTDOMAIN='pacaur'
export TEXTDOMAINDIR='/usr/share/locale'

# determine config location
if [[ "${XDG_CONFIG_DIRS}" ]]; then
    for i in ${XDG_CONFIG_DIRS//:/ }; do
        [[ -d "$i/pacaur" ]] && export XDG_CONFIG_DIRS="$i" && break
    done
fi
configdir="${XDG_CONFIG_DIRS:-/etc/xdg}/pacaur"
userconfigdir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacaur"
userpacmandir="${XDG_CONFIG_HOME:-${HOME}/.config}/pacman"
usercachedir="${XDG_CACHE_HOME:-${HOME}/.cache}/pacaur"
tmpdir="${XDG_RUNTIME_DIR:-/tmp}"

# preserve environment variables
var=('PACMAN' {'PKG','SRC'}{'DEST','EXT'} {'SRCPKG','LOG'}'DEST' 'BUILDDIR' 'GPGKEY' 'PACKAGER' 'CARCH')
for i in "${var[@]}"; do
    [[ "${!i}" ]] && declare _"$i"="${!i}"
done

# source makepkg variables
if [[ -r "$MAKEPKG_CONF" ]]; then
    source "$MAKEPKG_CONF"
else
    source /etc/makepkg.conf
    if [[ -r "$userpacmandir/makepkg.conf" ]]; then
        source "$userpacmandir/makepkg.conf"
    elif [[ -r "$HOME/.makepkg.conf" ]]; then
        source "$HOME/.makepkg.conf"
    fi
fi

# restore environment variables
for i in "${var[@]/#/_}"; do
    declare "${i//_}"="${!i:-${!i//_}}"
done

# set default config variables
editor="${VISUAL:-"${EDITOR:-vi}"}"         # build files editor
displaybuildfiles=diff                      # display build files (none|diff|full)
silent=false                                # silence output
sortby=name                                 # sort method (name|votes|popularity)
sortorder=ascending                         # sort order (ascending|descending)
sudoloop=true                               # prevent sudo timeout

# set variables
declare -r pacmanbin="${PACMAN:-pacman}"    # pacman binary
clonedir="${AURDEST:-${usercachedir:?}}"    # clone directory

# source xdg config
[[ -r "$configdir/config" ]] && source "$configdir/config"
[[ -r "$userconfigdir/config" ]] && source "$userconfigdir/config"

# source makepkg libraries
for i in parseopts util option error; do
    source "/usr/share/makepkg/util/$i.sh"
done
check_buildoption "check" "y" && checkdeps=1

# determine whether we have gettext; make it a no-op if we do not
type -p gettext >/dev/null || gettext() { printf '%s\n' "$@"; }

# set up directories
declare -r clonedir="$(canonicalize_path "$clonedir")"
install -dm700 "$clonedir"

# define vcs packages
declare -r vcs='-(cvs|svn|git|hg|bzr|darcs|daily.*|nightly.*)$'

# set variables to readonly
declare -r configdir userconfigdir userpacmandir usercachedir tmpdir

#
# Functions
#

ClassifyPkgs() {
    local noaurpkgs norepopkgs
    # global aurpkgs repopkgs
    [[ "$repo" ]] && repopkgs=("${pkgs[@]}")
    if [[ "$aur" ]]; then
        for i in "${pkgs[@]}"; do
            [[ "$i" = aur/* ]] && aurpkgs+=("${i:4}") && continue # search aur/pkgs in AUR
            aurpkgs+=("$i")
        done
    fi
    if [[ ! "$repo" && ! "$aur" ]]; then
        unset noaurpkgs
        for i in "${pkgs[@]}"; do
            [[ "$i" = aur/* ]] && aurpkgs+=("${i:4}") && continue # search aur/pkgs in AUR
            noaurpkgs+=("$i")
        done
        [[ "${noaurpkgs[*]}" ]] &&
            mapfile -t norepopkgs < <(expac -Sv '' -- "${noaurpkgs[@]}" 2>&1 >/dev/null) &&
            norepopkgs=("${norepopkgs[@]#error: package \`}") &&
            norepopkgs=("${norepopkgs[@]%\' not found}")
        for i in "${norepopkgs[@]}"; do
            # do not search repo/pkgs in AUR
            [[ " ${noaurpkgs[*]} " =~ [a-zA-Z0-9\.\+-]+\/"$i"[^a-zA-Z0-9\.\+-] ]] ||
                aurpkgs+=("$i") # do not search repo/pkgs in AUR
        done
        repopkgs=($(CommArr 'aurpkgs' 'noaurpkgs' '-13'))
    fi
}

Core() {
    GetIgnoredPkgs
    GetIgnoredGrps
    [[ "$upgrade" ]] && UpgradeAur
    IgnoreChecks
    DepsSolver
    IgnoreDepsChecks
    ProviderChecks
    ConflictChecks
    ReinstallChecks
    OutofdateChecks
    OrphanChecks
    Prompt
    MakePkgs
}

UpgradeAur() {
    local foreignpkgs allaurpkgs aurforeignpkgs i json
    # global aurpkgs
    Note "i" $"${colorW}Starting AUR upgrade...${reset}"
    foreignpkgs=($("$pacmanbin" -Qmq))
    SetJson "${foreignpkgs[@]}"
    allaurpkgs=($(GetJson "$json" "Name"))

    # foreign packages check
    aurforeignpkgs=($(CommArr 'allaurpkgs' 'foreignpkgs' '-13'))
    for i in "${aurforeignpkgs[@]}"; do
        Note "w" $"${colorW}$i${reset} is ${colorY}not present${reset} in AUR -- skipping"
    done

    # use auracle to find out of date AUR packages
    mapfile -t aurpkgs < <(auracle sync -q)

    # add devel packages
    if [[ "$devel" ]]; then
        for i in "${allaurpkgs[@]}"; do
            [[ "$i" =~ $vcs && ! " ${aurpkgs[*]} " =~ " $i " ]] && aurpkgs+=("$i")
        done
    fi

    aurpkgs+=("${pkgs[@]}")

    # avoid possible duplicate
    aurpkgs=($(printf '%s\n' "${aurpkgs[@]}" | sort -u))

    NothingToDo "${aurpkgs[@]}"
}

IgnoreChecks() {
    local checkaurpkgs checkaurpkgsAver checkaurpkgsQver checkaurpkgsgrp i json
    # global aurpkgs rmaurpkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # check targets
    SetJson "${aurpkgsnover[@]}"
    checkaurpkgs=($(GetJson "$json" "Name"))
    errdeps=($(CommArr 'aurpkgs' 'checkaurpkgs' '-3'))
    unset aurpkgsnover

    checkaurpkgsAver=($(GetJson "$json" "Version"))
    checkaurpkgsQver=($(expac -Q '%v' "${checkaurpkgs[@]}"))
    for i in "${!checkaurpkgs[@]}"; do
        [[ "${checkaurpkgs[$i]}" =~ $vcs ]] && checkaurpkgsAver[$i]=$"latest"
    done
    for i in "${!checkaurpkgs[@]}"; do
        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " ${checkaurpkgs[$i]} " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset checkaurpkgsgrp
            checkaurpkgsgrp=($(GetJson "$json" "Groups" "${checkaurpkgs[$i]}"))
            checkaurpkgsgrp+=($(expac -Q '%G' "${checkaurpkgs[$i]}"))
            for j in "${checkaurpkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]] ; then
            if [[ ! "$upgrade" ]]; then
                if [[ ! "$noconfirm" ]]; then
                    if ! Proceed "y" $"${checkaurpkgs[$i]} is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                        Note "w" $"skipping target: ${colorW}${checkaurpkgs[$i]}${reset}"
                        rmaurpkgs+=("${checkaurpkgs[$i]}")
                        continue
                    fi
                else
                    Note "w" $"skipping target: ${colorW}${checkaurpkgs[$i]}${reset}"
                    rmaurpkgs+=("${checkaurpkgs[$i]}")
                    continue
                fi
            else
                Note "w" $"${colorW}${checkaurpkgs[$i]}${reset}: ignoring package upgrade (${colorR}${checkaurpkgsQver[$i]}${reset} => ${colorG}${checkaurpkgsAver[$i]}${reset})"
                rmaurpkgs+=("${checkaurpkgs[$i]}")
                continue
            fi
        fi
        aurpkgsnover+=("${checkaurpkgs[$i]}")
    done

    aurpkgs=("${aurpkgsnover[@]}")
    NothingToDo "${aurpkgs[@]}"
}

DepsSolver() {
    local i aurpkgsconflicts
    # global aurpkgs aurpkgsnover aurpkgsproviders aurdeps deps json errdeps
    # global errdepsnover foreignpkgs repodeps depsAname depsAver depsAood depsQver
    Note "i" $"resolving dependencies..."

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # set unversioned json
    SetJson "${aurpkgsnover[@]}"

    # set targets providers
    aurpkgsproviders=("${aurpkgsnover[@]}")
    aurpkgsproviders+=($(GetJson "$json" "Provides"))
    aurpkgsproviders=("${aurpkgsproviders[@]%%[><=]*}")

    # check targets conflicts
    aurpkgsconflicts=($(GetJson "$json" "Conflicts"))
    if [[ "${aurpkgsconflicts[*]}" ]]; then
        aurpkgsconflicts=("${aurpkgsconflicts[@]%%[><=]*}")
        aurpkgsconflicts=($(CommArr 'aurpkgsproviders' 'aurpkgsconflicts' '-12'))
        for i in "${aurpkgsconflicts[@]}"; do
            [[ " ${aurpkgsnover[*]} " =~ " $i " ]] || continue
            [[ " $(GetJson "$json" "Conflicts" "$i") " =~ " $i " ]] && continue
            Note "f" $"unresolvable package conflicts detected"
            Note "e" $"failed to prepare transaction (conflicting dependencies: $i)" "$E_INSTALL_DEPS_FAILED"
        done
    fi

    deps=("${aurpkgsnover[@]}")

    [[ "${foreignpkgs[*]}" ]] || foreignpkgs=($("$pacmanbin" -Qmq))
    FindDepsAur "${aurpkgsnover[@]}"

    # avoid possible duplicate
    deps=($(CommArr 'aurdepspkgs' 'deps' '-13'))
    deps+=("${aurdepspkgs[@]}")

    # ensure correct dependency order
    SetJson "${deps[@]}"
    SortDepsAur "${aurpkgs[@]}"
    deps=($(tsort <<< "${tsortdeps[@]}")) || Note "e" $"dependency cycle detected" "$E_INSTALL_DEPS_FAILED"

    # get AUR packages info
    depsAname=($(GetJson "$json" "Name"))
    depsAver=($(GetJson "$json" "Version"))
    depsAood=($(GetJson "$json" "OutOfDate"))
    depsAmain=($(GetJson "$json" "Maintainer"))
    for i in "${!depsAname[@]}"; do
        read -rd' ' < <(expac -Qs '%v' "^${depsAname[$i]}$") depsQver[$i]
        [[ "${depsQver[$i]}" ]] || depsQver[$i]="%"  # avoid empty elements shift
        [[ "${depsAname[$i]}" =~ $vcs ]] && depsAver[$i]=$"latest"
    done

    # no results check
    if [[ "${errdeps[*]}" ]]; then
        for i in "${!errdepsnover[@]}"; do
            if [[ " ${aurpkgsnover[*]} " =~ " ${errdepsnover[$i]} " ]]; then
                Note "f" $"no results found for ${errdeps[$i]}"
            else
                unset tsorterrdeps errdepslist currenterrdep
                # find relevant tsorted deps chain
                for j in "${deps[@]}"; do
                    tsorterrdeps+=("$j")
                    [[ "$j" = "${errdepsnover[$i]}" ]] && break
                done
                # reverse deps order
                for i in "${!tsorterrdeps[@]}"; do
                    tsorterrdepsrev[$i]="${tsorterrdeps[-(($i+1))]}"
                done
                tsorterrdeps=("${tsorterrdepsrev[@]}") && unset tsorterrdepsrev
                errdepslist+=("${tsorterrdeps[0]}")
                FindDepsAurError "${tsorterrdeps[@]}"
                for i in "${!errdepslist[@]}"; do
                    errdepslistrev[$i]="${errdepslist[-(($i+1))]}"
                done
                errdepslist=("${errdepslistrev[@]}") && unset errdepslistrev
                Note "f" $"no results found for ${errdeps[$i]} (dependency tree: ${errdepslist[*]})"
            fi
        done
        exit "$E_INSTALL_DEPS_FAILED"
    fi

    # return all binary deps
    FindDepsRepo "${repodeps[@]}"

    # avoid possible duplicate
    repodepspkgs=($(printf '%s\n' "${repodepspkgs[@]}" | sort -u))
}

FindDepsAur() {
    local depspkgs depspkgstmp depspkgsaurtmp builtpkg vcsdepspkgs assumedepspkgs aurversionpkgs
    local aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff i j json
    # global aurpkgsnover depspkgsaur errdeps repodeps aurdepspkgs prevdepspkgsaur foreignpkgs
    [[ "$nodeps" && "$dcount" -ge 2 ]] && return

    # set json
    unset aurversionpkgs
    if [[ "${depspkgsaur[*]}" ]]; then
        SetJson "${depspkgsaur[@]}"
        for i in "${prevdepspkgsaur[@]}"; do
            [[ "$i" =~ [\>\<=] ]] && aurversionpkgs+=("$i")
        done
    else
        SetJson "${aurpkgsnover[@]}"
        for i in "${aurpkgs[@]}"; do
            [[ "$i" =~ [\>\<=] ]] && aurversionpkgs+=("$i")
        done
    fi

    # versioning check
    if [[ "${aurversionpkgs[*]}" ]]; then
        for i in "${!aurversionpkgs[@]}"; do
            unset aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff
            aurversionpkgsname="${aurversionpkgs[$i]%%[><=]*}"
            aurversionpkgsver="${aurversionpkgs[$i]##*[><=]}"
            aurversionpkgsaurver="$(GetJson "$json" "Version" "$aurversionpkgsname")"
            aurversionpkgsverdiff="$(vercmp "$aurversionpkgsaurver" "$aurversionpkgsver")"

            # not found in AUR nor repo
            [[ ! "$aurversionpkgsaurver" && ! " ${errdeps[*]} " =~ " ${aurversionpkgs[$i]} " ]] &&
                errdeps+=("${aurversionpkgs[$i]}") && continue

            case "${aurversionpkgs[$i]}" in
                *">"*|*"<"*|*"="*)
                    # found in AUR but version not correct
                    case "${aurversionpkgs[$i]}" in
                        *">="*) [[ "$aurversionpkgsverdiff" -ge 0 ]] && continue;;
                        *"<="*) [[ "$aurversionpkgsverdiff" -le 0 ]] && continue;;
                        *">"*)  [[ "$aurversionpkgsverdiff" -gt 0 ]] && continue;;
                        *"<"*)  [[ "$aurversionpkgsverdiff" -lt 0 ]] && continue;;
                        *"="*)  [[ "$aurversionpkgsverdiff" -eq 0 ]] && continue;;
                    esac
                    [[ " ${errdeps[*]} " =~ " ${aurversionpkgs[$i]} " ]] ||
                        errdeps+=("${aurversionpkgs[$i]}");;
                *) continue;;
            esac
        done
    fi

    depspkgs=($(GetJson "$json" "Depends"))

    # cached packages makedeps check
    if [[ ! "$PKGDEST" || "$rebuild" ]]; then
        depspkgs+=($(GetJson "$json" "MakeDepends"))
        [[ "$checkdeps" ]] && depspkgs+=($(GetJson "$json" "CheckDepends"))
    else
        [[ ! "${depspkgsaur[*]}" ]] && depspkgsaurtmp=("${aurpkgs[@]}") ||
            depspkgsaurtmp=("${depspkgsaur[@]}")
        for i in "${!depspkgsaurtmp[@]}"; do
            local depAname="$(GetJson "$json" "Name" "${depspkgsaurtmp[$i]}")"
            local depAver="$(GetJson "$json" "Version" "${depspkgsaurtmp[$i]}")"
            GetBuiltPkg "$depAname-$depAver" "$PKGDEST"
            if [[ ! "$builtpkg" ]]; then
                depspkgs+=($(GetJson "$json" "MakeDepends" "${depspkgsaurtmp[$i]}"))
                [[ "$checkdeps" ]] && depspkgs+=($(GetJson "$json" "CheckDepends"))
            fi
            unset builtpkg
        done
    fi

    # remove deps provided by targets
    [[ "${aurpkgsproviders[*]}" ]] && depspkgs=($(CommArr 'aurpkgsproviders' 'depspkgs' '-13'))

    # workaround for limited RPC support of architecture dependent fields
    if [[ "${CARCH}" = 'i686' ]]; then
        for i in "${!depspkgs[@]}"; do
            [[ "${depspkgs[$i]}" =~ ^(lib32-|gcc-multilib) ]] && unset depspkgs[$i]
        done
        depspkgs=($(printf '%s\n' "${depspkgs[@]}"))
    fi

    # remove versioning
    depspkgs=("${depspkgs[@]%%[><=]*}")
    # remove installed deps
    if [[ ! "$devel" ]]; then
        depspkgs=($("$pacmanbin" -T -- "${depspkgs[@]}" | sort -u))
    else
        # check providers
        unset vcsdepspkgs
        for i in "${!depspkgs[@]}"; do
            unset j && read -rd' ' < <(expac -Qs '%n %P' "^${depspkgs[$i]}$") j
            if [[ "$j" ]]; then
                depspkgs[$i]="$j"
                [[ "$devel" && ! " ${ignoredpkgs[*]} " =~ " $j " && "$j" =~ $vcs ]] &&
                    vcsdepspkgs+=("$j")
            else
                foreignpkgs+=("${depspkgs[$i]}")
            fi
        done
        # reorder devel
        depspkgs=($("$pacmanbin" -T -- "${depspkgs[@]}" | sort -u))
        depspkgs=($(CommArr 'depspkgs' 'vcsdepspkgs' '-3'))
    fi

    # split repo and AUR depends pkgs
    unset depspkgsaur
    if [[ "${depspkgs[*]}" ]]; then
        # remove all pkgs versioning
        if [[ "$nodeps" && "$dcount" -eq 1 ]]; then
            depspkgs=("${depspkgs[@]%%[><=]*}")
        # assume installed deps
        elif [[ "${assumeinstalled[*]}" ]]; then
            # remove versioning
            assumeinstalled=("${assumeinstalled[@]%%[><=]*}")
            for i in "${!assumeinstalled[@]}"; do
                unset assumedepspkgs
                for j in "${!depspkgs[@]}"; do
                    assumedepspkgs[$j]="${depspkgs[$j]%%[><=]*}"
                    [[ " ${assumedepspkgs[*]} " =~ " ${assumeinstalled[$i]} " ]] &&
                        depspkgs[$j]="${assumeinstalled[$i]}";
                done
            done
            depspkgs=($(CommArr 'assumeinstalled' 'depspkgs' '-13'))
        fi
        if [[ "${depspkgs[*]}" ]]; then
            mapfile -t depspkgsaur < <(expac -Sv '' -- "${depspkgs[@]%%[><=]*}" 2>&1) &&
            depspkgsaur=("${depspkgsaur[@]#error: package \`}") &&
            depspkgsaur=("${depspkgsaur[@]%\' not found}")
            repodeps+=($(CommArr 'depspkgsaur' 'depspkgs' '-13'))
        fi
    fi
    unset depspkgs

    # remove duplicate
    [[ "${depspkgsaur[*]}" ]] && depspkgsaur=($(CommArr 'aurdepspkgs' 'depspkgsaur' '-13'))

    # dependency cycle check
    [[ "${prevdepspkgsaur[*]}" && "${prevdepspkgsaur[*]}" = "${depspkgsaur[*]}" ]] &&
        Note "e" $"dependency cycle detected (${depspkgsaur[*]})" "$E_INSTALL_DEPS_FAILED"

    if [[ "${depspkgsaur[*]}" ]]; then
        # store for AUR version check
        [[ "$nodeps" ]] || prevdepspkgsaur=("${depspkgsaur[@]}")
        # remove duplicates and versioning
        depspkgsaur=($(printf '%s\n' "${depspkgsaur[@]%%[><=]*}" | sort -u))
    fi

    [[ "${depspkgsaur[*]}" ]] && aurdepspkgs+=("${depspkgsaur[@]}") &&
        FindDepsAur "${depspkgsaur[@]}"
}

SortDepsAur() {
    local i j sortaurpkgs sortdepspkgs sortdepspkgsaur
    # global checkedsortdepspkgsaur allcheckedsortdepspkgsaur json errdepsnover
    [[ "${checkedsortdepspkgsaur[*]}" ]] && sortaurpkgs=("${checkedsortdepspkgsaur[@]}") ||
        sortaurpkgs=("${aurpkgs[@]}")

    unset checkedsortdepspkgsaur
    for i in "${!sortaurpkgs[@]}"; do
        unset sortdepspkgs sortdepspkgsaur

        sortdepspkgs+=($(GetJson "$json" "Depends" "${sortaurpkgs[$i]}"))
        sortdepspkgs+=($(GetJson "$json" "MakeDepends" "${sortaurpkgs[$i]}"))
        [[ "$checkdeps" ]] && sortdepspkgs+=($(GetJson "$json" "CheckDepends"))

        # remove versioning
        errdepsnover=("${errdeps[@]%%[><=]*}")

        # check AUR deps only
        for j in "${!sortdepspkgs[@]}"; do
            sortdepspkgs[$j]="${sortdepspkgs[$j]%%[><=]*}"
            sortdepspkgsaur+=($(GetJson "$json" "Name" "${sortdepspkgs[$j]}"))
            # add erroneous AUR deps
            [[ " ${errdepsnover[*]} " =~ " ${sortdepspkgs[$j]} " ]] &&
                sortdepspkgsaur+=("${sortdepspkgs[$j]}")
        done

        # prepare tsort list
        if [[ ! "${sortdepspkgsaur[*]}" ]]; then
            tsortdeps+=("${sortaurpkgs[$i]} ${sortaurpkgs[$i]}")
        else
            for j in "${!sortdepspkgsaur[@]}"; do
                tsortdeps+=("${sortaurpkgs[$i]} ${sortdepspkgsaur[$j]}")
            done
        fi

        # filter non checked deps
        sortdepspkgsaur=($(CommArr 'allcheckedsortdepspkgsaur' 'sortdepspkgsaur' '-13'))
        if [[ "${sortdepspkgsaur[*]}" ]]; then
            checkedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur=($(printf '%s\n' "${allcheckedsortdepspkgsaur[@]}" | sort -u))
        fi
    done
    if [[ "${checkedsortdepspkgsaur[*]}" ]]; then
        checkedsortdepspkgsaur=($(printf '%s\n' "${checkedsortdepspkgsaur[@]}" | sort -u))
        SortDepsAur "${checkedsortdepspkgsaur[@]}"
    fi
}

FindDepsAurError() {
    local i nexterrdep nextallerrdeps
    # global errdepsnover errdepslist tsorterrdeps currenterrdep

    for i in "${tsorterrdeps[@]}"; do
        [[ " ${errdepsnover[*]} " =~ " $i " || " ${errdepslist[*]} " =~ " $i " ]] ||
            nexterrdep="$i" && break
    done

    [[ "${currenterrdep[*]}" ]] || currenterrdep="${tsorterrdeps[0]}"
    if [[ ! " ${aurpkgs[*]} " =~ " $nexterrdep " ]]; then
        nextallerrdeps=($(GetJson "$json" "Depends" "$nexterrdep"))
        nextallerrdeps+=($(GetJson "$json" "MakeDepends" "$nexterrdep"))
        [[ "$checkdeps" ]] && nextallerrdeps+=($(GetJson "$json" "CheckDepends"))

        # remove versioning
        nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

        [[ " ${nextallerrdeps[*]} " =~ " $currenterrdep " ]] && errdepslist+=("$nexterrdep") &&
            currenterrdep="${tsorterrdeps[0]}"
        tsorterrdeps=("${tsorterrdeps[@]:1}")
        FindDepsAurError "${tsorterrdeps[@]}"
    else
        for i in "${!aurpkgs[@]}"; do
            nextallerrdeps=($(GetJson "$json" "Depends" "${aurpkgs[$i]}"))
            nextallerrdeps+=($(GetJson "$json" "MakeDepends" "${aurpkgs[$i]}"))
            [[ "$checkdeps" ]] && nextallerrdeps+=($(GetJson "$json" "CheckDepends"))

            # remove versioning
            nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

            [[ " ${nextallerrdeps[*]} " =~ " $currenterrdep " ]] && errdepslist+=("${aurpkgs[$i]}")
        done
    fi
}

FindDepsRepo() {
    local allrepodepspkgs repodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${repodeps[*]}" ]] || return

    # reduce root binary deps
    repodeps=($(sort -u < <(printf '%s\n' "${repodeps[@]}")))

    # add initial repodeps
    [[ "${repodepspkgs[*]}" ]] || repodepspkgs=("${repodeps[@]}")

    # get non installed binary deps
    unset allrepodepspkgs repodepspkgstmp
    # no version check needed as all deps are repo deps
    [[ "${repodeps[*]}" ]] && allrepodepspkgs=($(expac -S1 '%E' "${repodeps[@]}"))
    [[ "${allrepodepspkgs[*]}" ]] &&
        repodepspkgstmp=($("$pacmanbin" -T -- "${allrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${repodepspkgstmp[*]}" ]] &&
        repodepspkgstmp=($(CommArr 'repodepspkgs' 'repodepspkgstmp' '-13'))

    [[ "${repodepspkgstmp[*]}" ]] && repodepspkgs+=("${repodepspkgstmp[@]}") &&
        repodeps=("${repodepspkgstmp[@]}") && FindDepsRepo "${repodeps[@]}"
}

FindDepsRepoProvider() {
    local allrepodepspkgs providerrepodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${providerspkgs[*]}" ]] || return

    # reduce root binary deps
    providerspkgs=($(printf '%s\n' "${providerspkgs[@]}" | sort -u))

    # get non installed repo deps
    unset allproviderrepodepspkgs providerrepodepspkgstmp
    [[ "${providerspkgs[*]}" ]] &&
        allproviderrepodepspkgs=($(expac -S1 '%E' "${providerspkgs[@]}"))
    # no version check needed as all deps are binary
    [[ "${allproviderrepodepspkgs[*]}" ]] &&
        providerrepodepspkgstmp=($("$pacmanbin" -T -- "${allproviderrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${providerrepodepspkgstmp[*]}" ]] &&
        providerrepodepspkgstmp=($(CommArr 'repodepspkgs' 'providerrepodepspkgstmp' '-13'))

    if [[ "${providerrepodepspkgstmp[*]}" ]]; then
        repodepspkgs+=("${providerrepodepspkgstmp[@]}")
        providerspkgs=("${providerrepodepspkgstmp[@]}")
        FindDepsRepoProvider "${providerspkgs[@]}"
    fi
}

IgnoreDepsChecks() {
    local i
    # global ignoredpkgs aurpkgs aurdepspkgs aurdepspkgsAgrp aurdepspkgsQgrp repodepspkgsSgrp
    # global repodepspkgsQgrp rmaurpkgs deps repodepspkgs
    [[ ! "${ignoredpkgs[*]}" && ! "${ignoredgrps[*]}" ]] && return

    # add checked targets and preserve tsorted order
    deps=("${deps[@]:0:${#aurpkgs[@]}}")

    # check dependencies
    for i in "${repodepspkgs[@]}"; do
        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " $i " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset repodepspkgsSgrp repodepspkgsQgrp
            repodepspkgsSgrp=($(expac -S1 '%G' "$i"))
            repodepspkgsQgrp=($(expac -Q '%G' "$i"))
            for j in "${repodepspkgsSgrp[@]}" "${repodepspkgsQgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]]; then
            [[ ! "$upgrade" ]] && Note "w" $"skipping target: ${colorW}$i${reset}" ||
                Note "w" $"${colorW}$i${reset}: ignoring package upgrade"
            Note "e" $"Unresolved dependency '${colorW}$i${reset}'" "$E_INSTALL_DEPS_FAILED"
        fi
    done
    for i in "${aurdepspkgs[@]}"; do
        # skip already checked dependencies
        [[ " ${aurpkgs[*]} " =~ " $i " ]] && continue
        [[ " ${rmaurpkgs[*]} " =~ " $i " ]] &&
            Note "e" $"Unresolved dependency '${colorW}$i${reset}'" "$E_INSTALL_DEPS_FAILED"

        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " $i " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset aurdepspkgsAgrp aurdepspkgsQgrp
            aurdepspkgsAgrp=($(GetJson "$json" "Groups" "$i"))
            aurdepspkgsQgrp=($(expac -Q '%G' "$i"))
            for j in "${aurdepspkgsAgrp[@]}" "${aurdepspkgsQgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]]; then
            if [[ ! "$noconfirm" ]]; then
                if ! Proceed "y" $"$i dependency is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                    Note "w" $"skipping target: ${colorW}$i${reset}"
                    Note "e" $"Unresolved dependency '${colorW}$i${reset}'" "$E_INSTALL_DEPS_FAILED"
                fi
            else
                [[ "$upgrade" ]] && Note "w" $"${colorW}$i${reset}: ignoring package upgrade" ||
                    Note "w" $"skipping target: ${colorW}$i${reset}"
                Note "e" $"Unresolved dependency '${colorW}$i${reset}'" "$E_INSTALL_DEPS_FAILED"
            fi
        fi
        deps+=("$i")
    done
}

ProviderChecks() {
    local providersdeps providersdepsnover providers repodepspkgsprovided providerspkgs provided
    local nb providersnb
    # global repodepspkgs repoprovidersconflictingpkgs repodepsSver repodepsSrepo repodepsQver
    [[ ! "${repodepspkgs[*]}" ]] && return

    # filter directly provided deps
    noprovidersdeps=($(expac -S1 '%n' "${repodepspkgs[@]}"))
    providersdeps=($(CommArr 'noprovidersdeps' 'repodepspkgs' '-13'))

    # remove installed providers
    providersdeps=($("$pacmanbin" -T -- "${providersdeps[@]}" | sort -u))

    for i in "${!providersdeps[@]}"; do
        # check versioning
        unset providersdepsname providersdepsver providersdepsSname providersdepsSver
        providersdepsname="${providersdeps[$i]%%[><=]*}"
        providersdepsver="${providersdeps[$i]##*[><=]}"
        providersdepsSname=($(expac -Ss '%n' "^${providersdepsname[$i]}$"))
        providersdepsSver=($(expac -Ss '%v' "^${providersdepsname[$i]}$"))

        case "${providersdeps[$i]}" in
            *">"*|*"<"*|*"="*)
                for j in "${!providersdepsSname[@]}"; do
                    unset providersdepverdiff
                    providersdepsverdiff="$(vercmp "$providersdepsver" "${providersdepsSver[j]}")"
                    # found in repo but version not correct
                    case "${providersdeps[$i]}" in
                        *">="*) [[ "$providersdepsverdiff" -ge 0 ]] && continue;;
                        *"<="*) [[ "$providersdepsverdiff" -le 0 ]] && continue;;
                        *">"*)  [[ "$providersdepsverdiff" -gt 0 ]] && continue;;
                        *"<"*)  [[ "$providersdepsverdiff" -lt 0 ]] && continue;;
                        *"="*)  [[ "$providersdepsverdiff" -eq 0 ]] && continue;;
                    esac
                    providersdepsnover+=("${providersdepsSname[j]}")
                done
            ;;
        esac

        # remove versioning
        providersdeps[$i]="${providersdeps[$i]%%[><=]*}"

        # list providers
        providers=($(expac -Ss '%n' "^${providersdeps[$i]}$" | sort -u))

        # filter out non matching versioned providers
        [[ "${providersdepsnover[*]}" ]] && providers=($(CommArr 'providersdepsnover' 'providers' '-12'))

        # skip if provided in dependency chain
        unset repodepspkgsprovided
        for j in "${!providers[@]}"; do
            [[ " ${repodepspkgs[*]} " =~ " ${providers[$j]} " ]] && repodepspkgsprovided='true'
        done
        [[ "$repodepspkgsprovided" ]] && continue

        # skip if already provided
        if [[ "${providerspkgs[*]}" ]]; then
            providerspkgs=($(tr ' ' '|' <<< "${providerspkgs[@]}"))
            provided+=($(expac -Ss '%S' "^(${providerspkgs[*]})$"))
            [[ " ${provided[*]} " =~ " ${providersdeps[$i]} " ]] && continue
        fi

        if [[ ! "$noconfirm" && "${#providers[*]}" -gt 1 ]]; then
            Note "i" $"${colorW}There are ${#providers[@]} providers available for ${providersdeps[$i]}:${reset}"
            expac -S1 '   %!) %n (%r) ' "${providers[@]}"

            nb=-1
            providersnb="$(( "${#providers[@]}" -1 ))" # count from 0
            while [[ "$nb" -lt 0 || "$nb" -ge "${#providers}" ]]; do
                printf "\n%s " $"Enter a number (default=0):"
                case "$TERM" in
                    dumb)
                    read -r nb
                    ;;
                    *)
                    read -r -n "$(printf '%s' "$providersnb" | wc -m)" nb
                    printf '\n'
                    ;;
                esac

                case "$nb" in
                    [0-9]|[0-9][0-9])
                        if [[ "$nb" -lt 0 || "$nb" -ge "${#providers[@]}" ]]; then
                            printf '\n'
                            Note "f" $"invalid value: $nb is not between 0 and $providersnb"
                            ((i--))
                        else
                            break
                        fi;;
                    '') nb=0;;
                    *) Note "f" $"invalid number: $nb";;
                esac
            done
        else
            nb=0
        fi
        providerspkgs+=("${providers[$nb]}")
    done

    # add selected providers to repo deps
    repodepspkgs+=("${providerspkgs[@]}")

    # store for installation
    repoprovidersconflictingpkgs+=("${providerspkgs[@]}")

    FindDepsRepoProvider "${providerspkgs[@]}"

    # get binary packages info
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepspkgs=($(expac -S1 '%n' "${repodepspkgs[@]}" | sort -u))
        repodepsSver=($(expac -S1 '%v' "${repodepspkgs[@]}"))
        repodepsQver=($(expac -Q '%v' "${repodepspkgs[@]}"))
        repodepsSrepo=($(expac -S1 '%r/%n' "${repodepspkgs[@]}"))
    fi
}

ConflictChecks() {
    local allQprovides allQconflicts Aprovides Aconflicts aurconflicts aurAconflicts Qrequires i j
    local k l repodepsprovides repodepsconflicts checkedrepodepsconflicts repodepsconflictsname
    local repodepsconflictsver localver repoconflictingpkgs
    # global deps depsAname json aurdepspkgs aurconflictingpkgs aurconflictingpkgsrm depsQver
    # global repodepspkgs repoconflictingpkgsrm repoprovidersconflictingpkgs
    Note "i" $"looking for inter-conflicts..."

    allQprovides=($(expac -Q '%n'))
    allQprovides+=($(expac -Q '%S')) # no versioning
    allQconflicts=($(expac -Q '%C'))

    # AUR conflicts
    Aprovides=("${depsAname[@]}")
    Aprovides+=($(GetJson "$json" "Provides"))
    Aconflicts=($(GetJson "$json" "Conflicts"))
    # remove AUR versioning
    Aprovides=("${Aprovides[@]%%[><=]*}")
    Aconflicts=("${Aconflicts[@]%%[><=]*}")
    aurconflicts=($(CommArr 'Aprovides' 'allQconflicts' '-12'))
    aurconflicts+=($(CommArr 'Aconflicts' 'allQprovides' '-12'))
    aurconflicts=($(printf '%s\n' "${aurconflicts[@]}" | sort -u))

    for i in "${aurconflicts[@]}"; do
        unset aurAconflicts
        [[ " ${depsAname[*]} " =~ " $i " ]] && aurAconflicts=("$i")
        for j in "${depsAname[@]}"; do
            [[ " $(GetJson "$json" "Conflicts" "$j") " =~ " $i " ]] && aurAconflicts+=("$j")
        done

        for j in "${aurAconflicts[@]}"; do
            unset k Aprovides
            read -rd' ' < <(expac -Qs '%n %P' "^$i$") k
            [[ ! "$installpkg" && ! " ${aurdepspkgs[*]} " =~ " $j " ]] && continue # download only
            [[ "$j" = "$k" || ! "$k" ]] && continue # skip if reinstalling or if no conflict exists

            Aprovides=("$j")
            if [[ ! "$noconfirm" && ! " ${aurconflictingpkgs[*]} " =~ " $k " ]]; then
                if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                    aurconflictingpkgs+=("$j" "$k")
                    aurconflictingpkgsrm+=("$k")
                    for l in "${!depsAname[@]}"; do
                        [[ " ${depsAname[$l]} " =~ "$k" ]] &&
                            read -rd' ' < <(expac -Qs '%v' "^$k$") depsQver[$l]
                    done
                    Aprovides+=($(GetJson "$json" "Provides" "$j"))
                    # remove AUR versioning
                    Aprovides=("${Aprovides[@]%%[><=]*}")
                    [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " =~ " $k " ]] &&
                        CheckRequires "$k"
                    break
                else
                    Note "f" $"unresolvable package conflicts detected"
                    Note "f" $"failed to prepare transaction (conflicting dependencies)"
                    if [[ "$upgrade" ]]; then
                        Qrequires=($(expac -Q '%N' "$i"))
                        Note "e" $"$j and $k are in conflict (required by ${Qrequires[*]})" "$E_INSTALL_DEPS_FAILED"
                    else
                        Note "e" $"$j and $k are in conflict" "$E_INSTALL_DEPS_FAILED"
                    fi
                fi
            fi
            Aprovides+=($(GetJson "$json" "Provides" "$j"))
            # remove AUR versioning
            Aprovides=("${Aprovides[@]%%[><=]*}")
            [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " =~ " $k " ]] && CheckRequires "$k"
        done
    done

    NothingToDo "${deps[@]}"

    # repo conflicts
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepsprovides=("${repodepspkgs[@]}")
        repodepsprovides+=($(expac -S1 '%S' "${repodepspkgs[@]}")) # no versioning
        repodepsconflicts=($(expac -S1 '%H' "${repodepspkgs[@]}"))

        # versioning check
        unset checkedrepodepsconflicts
        for i in "${!repodepsconflicts[@]}"; do
            unset repodepsconflictsname repodepsconflictsver localver
            repodepsconflictsname="${repodepsconflicts[$i]%%[><=]*}"
            repodepsconflictsver="${repodepsconflicts[$i]##*[><=]}"
            local localver="$(expac -Q '%v' "$repodepsconflictsname")"
            local repodepsconflictsverdiff="$(vercmp "$repodepsconflictsver" "$localver")"

            if [[ "$localver" ]]; then
                case "${repodepsconflicts[$i]}" in
                    *">="*) [[ "$repodepsconflictsverdiff" -ge 0 ]] && continue;;
                    *"<="*) [[ "$repodepsconflictsverdiff" -le 0 ]] && continue;;
                    *">"*)  [[ "$repodepsconflictsverdiff" -gt 0 ]] && continue;;
                    *"<"*)  [[ "$repodepsconflictsverdiff" -lt 0 ]] && continue;;
                    *"="*)  [[ "$repodepsconflictsverdiff" -eq 0 ]] && continue;;
                esac
                checkedrepodepsconflicts+=("$repodepsconflictsname")
            fi
        done

        repoconflicts+=($(CommArr 'repodepsprovides' 'allQconflicts' '-12'))
        repoconflicts+=($(CommArr 'checkedrepodepsconflicts' 'allQprovides' '-12'))
        repoconflicts=($(printf '%s\n' "${repoconflicts[@]}" | sort -u))
    fi

    for i in "${repoconflicts[@]}"; do
        unset Qprovides
        unset j && read -rd' ' < <(expac -Ss '%n %C %S' "^$i$") j
        unset k && read -rd' ' < <(expac -Qs '%n %C %S' "^$i$") k
        [[ "$j" = "$k" || ! "$k" ]] && continue # skip when no conflict with repopkgs
        if [[ ! "$noconfirm" && ! " ${repoconflictingpkgs[*]} " =~ " $k " ]]; then
            if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                repoconflictingpkgs+=("$j" "$k")
                repoconflictingpkgsrm+=("$k")
                repoprovidersconflictingpkgs+=("$j")
                Qprovides=($(expac -Ss '%S' "^$k$"))
                [[ ! " ${Qprovides[*]} ${repoconflictingpkgsrm[*]} " =~ " $k " ]] &&
                    CheckRequires "$k"
                break
            else
                Note "f" $"unresolvable package conflicts detected"
                Note "f" $"failed to prepare transaction (conflicting dependencies)"
                if [[ "$upgrade" ]]; then
                    Qrequires=($(expac -Q '%N' "$i"))
                    Note "e" $"$j and $k are in conflict (required by ${Qrequires[*]})" "$E_INSTALL_DEPS_FAILED"
                else
                    Note "e" $"$j and $k are in conflict" "$E_INSTALL_DEPS_FAILED"
                fi
            fi
        fi
        Qprovides=($(expac -Ss '%S' "^$k$"))
        [[ ! " ${Qprovides[*]} " =~ " $k " ]] && CheckRequires "$k"
    done
}

ReinstallChecks() {
    local i depsAtmp
    # global aurpkgs aurdepspkgs deps aurconflictingpkgs depsAname depsQver depsAver depsAood
    # global depsAmain
    depsAtmp=("${depsAname[@]}")
    for i in "${!depsAtmp[@]}"; do
        [[ ! " ${aurpkgs[*]} " =~ " ${depsAname[$i]} " ]] ||
            [[ " ${aurconflictingpkgs[*]} " =~ " ${depsAname[$i]} " ]] && continue
        [[ ! "${depsQver[$i]}" || "${depsQver[$i]}" = '%' ]] ||
            [[ "$(vercmp "${depsAver[$i]}" "${depsQver[$i]}")" -gt 0 ]] && continue
        [[ ! "$installpkg" && ! " ${aurdepspkgs[*]} " =~ " ${depsAname[$i]} " ]] && continue
        if [[ "${depsAname[$i]}" =~ $vcs ]]; then
            Note "w" $"${colorW}${depsAname[$i]}${reset} latest revision -- fetching"
        else
            if [[ ! $needed ]]; then
                Note "w" $"${colorW}${depsAname[$i]}-${depsQver[$i]}${reset} is up to date -- reinstalling"
            else
                Note "w" $"${colorW}${depsAname[$i]}-${depsQver[$i]}${reset} is up to date -- skipping"
                mapfile -t deps < <(printf ' %s \n' "${deps[@]}")
                deps=($(printf '%s\n' "${deps[@]// ${depsAname[$i]} /}"))
                unset "depsAname[$i]" "depsQver[$i]" "depsAver[$i]" "depsAood[$i]" "depsAmain[$i]"
            fi
        fi
    done
    [[ "$needed" ]] && depsAname=("${depsAname[@]}") && depsQver=("${depsQver[@]}") &&
        depsAver=("${depsAver[@]}") && depsAood=("${depsAood[@]}") && depsAmain=("${depsAmain[@]}")
    NothingToDo "${deps[@]}"
}

OutofdateChecks() {
    local i
    # global depsAname depsAver depsAood
    for i in "${!depsAname[@]}"; do
        [[ "${depsAood[$i]}" -gt 0 ]] &&
            Note "w" $"${colorW}${depsAname[$i]}-${depsAver[$i]}${reset} has been flagged ${colorR}out of date${reset} on ${colorY}$(date -d "@${depsAood[$i]}" "+%c")${reset}"
    done
}

OrphanChecks() {
    local i
    # global depsAname depsAver depsAmain
    for i in "${!depsAname[@]}"; do
        [[ "${depsAmain[$i]}" = 'null' || ! "${depsAmain[$i]}" ]] &&
            Note "w" $"${colorW}${depsAname[$i]}-${depsAver[$i]}${reset} is ${colorR}orphaned${reset} in AUR"
    done
}

Prompt() {
    local i binaryksize sumk summ builtpkg cachedpkgs stroldver strnewver strsize depsver
    local repodepspkgsver strrepodlsize strrepoinsize strsumk strsumm lreposizelabel lreposize
    # global repodepspkgs repodepsSver depsAname depsAver depsArepo depsAcached lname lver lsize
    # global deps depsQver repodepspkgs repodepsSrepo repodepsQver repodepsSver
    # compute binary size
    if [[ "${repodepspkgs[*]}" ]]; then
        binaryksize=($(expac -S1 '%k' "${repodepspkgs[@]}"))
        binarymsize=($(expac -S1 '%m' "${repodepspkgs[@]}"))
        sumk=0
        summ=0
        for i in "${!repodepspkgs[@]}"; do
            GetBuiltPkg "${repodepspkgs[$i]}-${repodepsSver[$i]}" '/var/cache/pacman/pkg'
            [[ "$builtpkg" ]] && binaryksize[$i]=0
            sumk="$((sumk + "${binaryksize[$i]}"))"
            summ="$((summ + "${binarymsize[$i]}"))"
        done
        sumk="$((sumk / 1048576)).$((sumk / 1024 % 1024 * 100 / 1024))"
        summ="$((summ / 1048576)).$((summ / 1024 % 1024 * 100 / 1024))"
    fi

    # cached packages check
    for i in "${!depsAname[@]}"; do
        [[ ! "$PKGDEST" || "$rebuild" ]] && break
        GetBuiltPkg "${depsAname[$i]}-${depsAver[$i]}" "$PKGDEST"
        [[ "$builtpkg" ]] && cachedpkgs+=("${depsAname[$i]}") && depsAcached[$i]=$"(cached)" ||
            depsAcached[$i]=""
        unset builtpkg
    done

    if [[ "$(pacman-conf VerbosePkgLists)" ]]; then
        straurname=$"AUR Packages  (${#deps[@]})"; strreponame=$"Repo Packages (${#repodepspkgs[@]})"
        stroldver=$"Old Version"; strnewver=$"New Version"; strsize=$"Download Size"
        depsArepo=("${depsAname[@]/#/aur/}")
        lname="$(GetLength "${depsArepo[@]}" "${repodepsSrepo[@]}" "$straurname" "$strreponame")"
        lver="$(GetLength "${depsQver[@]}" "${depsAver[@]}" "${repodepsQver[@]}" "${repodepsSver[@]}" "$stroldver" "$strnewver")"
        lsize="$(GetLength "$strsize")"

        # local version column cleanup
        for i in "${!deps[@]}"; do
            [[ "${depsQver[$i]}" =~ '%' ]] && unset depsQver[$i]
        done
        # show detailed output
        printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s${reset}\n\n" "$straurname" "$stroldver" "$strnewver"
        for i in "${!deps[@]}"; do
            printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" "${depsArepo[$i]}" "${depsQver[$i]}" "${depsAver[$i]}" "${depsAcached[$i]}";
        done

        if [[ "${repodepspkgs[*]}" ]]; then
            for i in "${!repodepspkgs[@]}"; do
                binarysize[$i]="$((binaryksize[$i] / 1048576)).$((binaryksize[$i] / 1024 % 1024 * 100 / 1024))"
            done
            printf "\n${colorW}%-${lname}s  %-${lver}s  %-${lver}s  %s${reset}\n\n" "$strreponame" "$stroldver" "$strnewver" "$strsize"
            for i in "${!repodepspkgs[@]}"; do
                printf "%-${lname}s  ${colorR}%-${lver}s${reset}  ${colorG}%-${lver}s${reset}  %${lsize}s\n" "${repodepsSrepo[$i]}" "${repodepsQver[$i]}" "${repodepsSver[$i]}" $"${binarysize[$i]} MiB";
            done
        fi
    else
        # show version
        for i in "${!deps[@]}"; do
            depsver="${depsver}${depsAname[$i]}-${depsAver[$i]}  "
        done
        for i in "${!repodepspkgs[@]}"; do
            repodepspkgsver="${repodepspkgsver}${repodepspkgs[$i]}-${repodepsSver[$i]}  "
        done
        printf "\n${colorW}%-16s${reset} %s\n" $"AUR Packages  (${#deps[@]})" "$depsver"
        [[ "${repodepspkgs[*]}" ]] && printf "${colorW}%-16s${reset} %s\n" $"Repo Packages (${#repodepspkgs[@]})" "$repodepspkgsver"
    fi

    if [[ "${repodepspkgs[*]}" ]]; then
        strrepodlsize=$"Repo Download Size:"; strrepoinsize=$"Repo Installed Size:"
        strsumk=$"$sumk MiB"; strsumm=$"$summ MiB"
        lreposizelabel="$(GetLength "$strrepodlsize" "$strrepoinsize")"
        lreposize="$(GetLength "$strsumk" "$strsumm")"
        printf "\n${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "$strrepodlsize" "$strsumk"
        printf "${colorW}%-${lreposizelabel}s${reset}  %${lreposize}s\n" "$strrepoinsize" "$strsumm"
    fi

    printf '\n'
    if [[ "$installpkg" ]]; then
        Proceed "y" $"Proceed with installation?" || exit "$E_FAIL"
    else
        Proceed "y" $"Proceed with download?" || exit "$E_FAIL"
    fi
}

DownloadPkgs() {
    local i
    # global basepkgs
    Note "i" $"${colorW}Retrieving package(s)...${reset}"
    GetPkgbase "$@"

    # no results check
    [[ ! "${basepkgs[*]}" ]] && Note "e" $"no results found" "$E_INSTALL_DEPS_FAILED"

    # reset
    for i in "${basepkgs[@]}"; do
        if [[ -d "$clonedir/$i" ]]; then
            git -C "$clonedir/$i" reset --hard HEAD -q # updated pkgver of vcs packages block pull
            [[ "$displaybuildfiles" = diff ]] &&
                git -C "$clonedir/$i" rev-parse HEAD > "$clonedir/$i/.git/HEAD.prev"
        fi
    done

    # clone
    auracle -C "$clonedir" clone "$@" >/dev/null ||
        Note "e" $"failed to retrieve packages" "$E_INSTALL_DEPS_FAILED"
}

EditPkgs() {
    local viewed i j erreditpkg
    # global cachedpkgs installscripts editor
    [[ "$noedit" ]] && return
    unset viewed
    for i in "$@"; do
        [[ " ${cachedpkgs[*]} " =~ " $i " ]] && continue
        GetInstallScripts "$i"
        if [[ ! "$pace" ]]; then
            if [[ "$displaybuildfiles" = diff && -e "$clonedir/$i/.git/HEAD.prev" ]]; then
                local prev="$(<"$clonedir/$i/.git/HEAD.prev")"
                # show diff
                if git -C "$clonedir/$i" diff --quiet --no-ext-diff "$prev" -- . ':!\.SRCINFO'; then
                    Note "w" $"${colorW}$i${reset} build files are up-to-date -- skipping"
                else
                    if Proceed "y" $"View $i build files diff?"; then
                        git -C "$clonedir/$i" diff --no-ext-diff "$prev" -- . ':!\.SRCINFO' ||
                            erreditpkg+=("$i")
                        Note "i" $"${colorW}$i${reset} build files diff viewed"; viewed=1
                    fi
                fi
            elif [[ ! "$displaybuildfiles" = none ]]; then
                # show pkgbuild
                if Proceed "y" $"View $i PKGBUILD?"; then
                    if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                        "$editor" "$clonedir/$i/PKGBUILD" &&
                            Note "i" $"${colorW}$i${reset} PKGBUILD viewed" || erreditpkg+=("$i")
                    else
                        Note "e" $"Could not open ${colorW}$i${reset} PKGBUILD" "$E_MISSING_FILE"
                    fi
                fi
                # show install script
                if [[ "${installscripts[*]}" ]]; then
                    for j in "${installscripts[@]}"; do
                        if Proceed "y" $"View $j script?"; then
                            if [[ -e "$clonedir/$i/$j" ]]; then
                                "$editor" "$clonedir/$i/$j" &&
                                    Note "i" $"${colorW}$j${reset} script viewed" ||
                                    erreditpkg+=("$i")
                            else
                                Note "e" $"Could not open ${colorW}$j${reset} script" "$E_MISSING_FILE"
                            fi
                        fi
                    done
                fi
            fi
        else
            # show pkgbuild and install script
            if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                "$editor" "$clonedir/$i/PKGBUILD" &&
                    Note "i" $"${colorW}$i${reset} PKGBUILD viewed" || erreditpkg+=("$i")
            else
                Note "e" $"Could not open ${colorW}$i${reset} PKGBUILD" "$E_MISSING_FILE"
            fi
            if [[ "${installscripts[*]}" ]]; then
                for j in "${installscripts[@]}"; do
                    if [[ -e "$clonedir/$i/$j" ]]; then
                        "$editor" "$clonedir/$i/$j" &&
                            Note "i" $"${colorW}$j${reset} script viewed" || erreditpkg+=("$i")
                    else
                        Note "e" $"Could not open ${colorW}$j${reset} script" "$E_MISSING_FILE"
                    fi
                done
            fi
        fi
    done

    if [[ "${erreditpkg[*]}" ]]; then
        for i in "${erreditpkg[@]}"; do
            Note "f" $"${colorW}$i${reset} errored on exit"
        done
        exit "$E_FAIL"
    fi

    if [[ "$displaybuildfiles" = diff && "$viewed" ]]; then
        if [[ "$installpkg" ]]; then
            Proceed "y" $"Proceed with installation?" || exit
        else
            Proceed "y" $"Proceed with download?" || exit
        fi
    fi
}

MakePkgs() {
    local i j k oldorphanpkgs neworphanpkgs orphanpkgs oldoptionalpkgs newoptionalpkgs optionalpkgs
    local errinstall pkgsdepslist vcsclients vcschecked aurdevelpkgsAver aurdevelpkgsQver
    local builtpkgs builtdepspkgs basepkgsupdate checkpkgsdepslist deplist isaurdeps makedeps
    # global deps basepkgs sudoloop pkgsbase pkgsdeps aurpkgs aurdepspkgs builtpkg errmakepkg json
    # global repoprovidersconflictingpkgs

    # download
    DownloadPkgs "${deps[@]}"
    EditPkgs "${basepkgs[@]}"

    # current orphan and optional packages
    oldorphanpkgs=($("$pacmanbin" -Qdtq))
    oldoptionalpkgs=($("$pacmanbin" -Qdttq))
    oldoptionalpkgs=($(CommArr 'oldorphanpkgs' 'oldoptionalpkgs' '-13'))

    # initialize sudo
    if sudo -n "$pacmanbin" -V > /dev/null || sudo -v; then
        [[ "$sudoloop" = true ]] && SudoV &
    fi

    # split packages support
    for i in "${!pkgsbase[@]}"; do
        for j in "${!deps[@]}"; do
            [[ "${pkgsbase[$i]}" = "${pkgsbase[$j]}" && ! " ${pkgsdeps[*]} " =~ " ${deps[$j]} " ]] &&
                pkgsdeps+=("${deps[$j]}")
        done
        pkgsdeps+=("%")
    done
    deplist="${pkgsdeps[@]}"; deplist="${deplist// % /|}"; deplist="${deplist//%}"
    deplist="${deplist// /,}"; deplist="${deplist//|/ }"; pkgsdeps=($(printf '%s\n' ${deplist}))

    # reverse deps order
    for i in "${!basepkgs[@]}"; do
        basepkgsrev[$i]="${basepkgs[-(($i+1))]}"
    done
    basepkgs=("${basepkgsrev[@]}") && unset basepkgsrev
    for i in "${!pkgsdeps[@]}"; do
        pkgsdepsrev[$i]="${pkgsdeps[-(($i+1))]}"
    done
    pkgsdeps=("${pkgsdepsrev[@]}") && unset pkgsdepsrev

    # integrity check
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        mapfile -t -d',' pkgsdepslist <<< "${pkgsdeps[$i]}"

        # cache check
        unset builtpkg
        if [[ ! "${basepkgs[$i]}" =~ $vcs ]]; then
            for j in "${pkgsdepslist[@]}"; do
                [[ "$PKGDEST" && ! "$rebuild" ]] &&
                    GetBuiltPkg "$j-$(GetJson "$json" "Version" "$j")" "$PKGDEST"
            done
        fi

        # install vcs clients (checking pkgbase extension only does not take fetching specific
        # commit into account)
        unset vcsclients
        makedeps=($(GetJson "$json" "MakeDepends" "${basepkgs[$i]}"))
        for i in git subversion mercurial bzr cvs darcsl; do
            [[ " ${makedeps[*]} " =~ " $i " ]] && vcsclients+=("$i")
        done
        unset makedeps
        for j in "${vcsclients[@]}"; do
            if [[ ! "${vcschecked[*]}" =~ "$j" ]]; then
                expac -Qs '' "^$j$" || sudo "$pacmanbin" -S --asdeps --noconfirm -- "$j"
                vcschecked+=("$j")
            fi
        done

        if [[ ! "$builtpkg" || "$rebuild" ]]; then
            cd_safe "$clonedir/${basepkgs[$i]}"
            Note "i" $"Checking ${colorW}${pkgsdeps[$i]}${reset} integrity..."
            if [[ "$silent" = true ]]; then
                makepkg -f --verifysource "${makeopts[@]}" &>/dev/null
            else
                makepkg -f --verifysource "${makeopts[@]}"
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
            # extraction, prepare and pkgver update
            Note "i" $"Preparing ${colorW}${pkgsdeps[$i]}${reset}..."
            if [[ "$silent" = true ]]; then
                makepkg -od --skipinteg "${makeopts[@]}" &>/dev/null
            else
                makepkg -od --skipinteg "${makeopts[@]}"
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
        fi
    done
    if [[ "${errmakepkg[*]}" || "${errinstall[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            Note "f" $"failed to verify integrity or prepare ${colorW}$i${reset} package"
        done
        # remove sudo lock
        rm -f "${tmpdir:?}/pacaur.sudov.lck"
        exit "$E_FAIL"
    fi

    # check database lock
    [[ -e "/var/lib/pacman/db.lck" ]] && Note "e" $"db.lck exists in /var/lib/pacman" "$E_FAIL"

    # set build lock
    [[ -e "$tmpdir/pacaur.build.lck" ]] && Note "e" $"pacaur.build.lck exists in $tmpdir" "$E_FAIL"
    touch "$tmpdir/pacaur.build.lck"

    # install provider packages and repo conflicting packages that makepkg --noconfirm cannot handle
    if [[ "${repoprovidersconflictingpkgs[*]}" ]]; then
        Note "i" $"Installing ${colorW}${repoprovidersconflictingpkgs[@]}${reset} dependencies..."
        sudo "$pacmanbin" -S "${repoprovidersconflictingpkgs[@]}" --ask 36 --asdeps --noconfirm
    fi

    # main
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        mapfile -t -d',' pkgsdepslist <<< "${pkgsdeps[$i]}"

        cd_safe "$clonedir/${basepkgs[$i]}"
        # retrieve updated version
        mapfile -t -d'-' k < <(makepkg --packagelist) && aurdevelpkgsAver="${k[-3]}-${k[-2]}"
        unset k
        # build devel if necessary only (supported protocols only)
        if [[ "${basepkgs[$i]}" =~ $vcs ]]; then
            # check split packages update
            unset basepkgsupdate checkpkgsdepslist
            for j in "${pkgsdepslist[@]}"; do
                read -rd' ' < <(expac -Qs '%v' "^$j$") aurdevelpkgsQver
                if [[ "$needed" && ! "$rebuild" && "$aurdevelpkgsQver" ]] &&
                    [[ "$(vercmp "$aurdevelpkgsQver" "$aurdevelpkgsAver")" -ge 0 ]]; then
                    Note "w" $"${colorW}$j${reset} is up-to-date -- skipping" && continue
                else
                    basepkgsupdate='true'
                    checkpkgsdepslist+=("$j")
                fi
            done
            [[ "$basepkgsupdate" ]] && pkgsdepslist=("${checkpkgsdepslist[@]}") || continue
        fi

        # check package cache
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            [[ "$PKGDEST" && ! "$rebuild" ]] && GetBuiltPkg "$j-$aurdevelpkgsAver" "$PKGDEST"
            if [[ "$builtpkg" ]]; then
                if [[ " ${aurdepspkgs[*]} " =~ " $j " || "$installpkg" ]]; then
                    Note "i" $"Installing ${colorW}$j${reset} cached package..."
                    sudo "$pacmanbin" -U --ask 36 ${pacopts[@]/--quiet} --noconfirm -- "$builtpkg"
                    [[ " ${aurpkgs[*]} " =~ " $j " ]] ||
                        sudo "$pacmanbin" -D "$j" --asdeps ${pacopts[@]} &>/dev/null
                else
                    Note "w" $"Package ${colorW}$j${reset} already available in cache"
                fi
                pkgsdeps=($(printf '%s\n' "${pkgsdeps[@]}" | sed "s/^$j,//g;s/,$j$//g;s/,$j,/,/g;s/^$j$/%/g"))
                continue
            fi
        done
        [[ "${pkgsdeps[$i]}" = '%' ]] && continue

        # build
        Note "i" $"Building ${colorW}${pkgsdeps[$i]}${reset} package(s)..."

        # install then remove binary deps
        makeopts=("${makeopts[@]/-r/}")

        if [[ ! "$installpkg" ]]; then
            unset isaurdeps
            for j in "${pkgsdepslist[@]}"; do
                [[ " ${aurdepspkgs[*]} " =~ " $j " ]] && isaurdeps=1
            done
            [[ "$isaurdeps" ]] && makeopts+=("-r")
        fi

        if [[ "$silent" = true ]]; then
            makepkg -sefc "${makeopts[@]}" --noconfirm &>/dev/null
        else
            makepkg -sefc "${makeopts[@]}" --noconfirm
        fi

        # error check
        (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}") && continue # skip install

        # retrieve filename
        unset builtpkgs builtdepspkgs
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            if [[ "$PKGDEST" ]]; then
                GetBuiltPkg "$j-$aurdevelpkgsAver" "$PKGDEST"
            else
                GetBuiltPkg "$j-$aurdevelpkgsAver" "$clonedir/${basepkgs[$i]}"
            fi
            [[ " ${aurdepspkgs[*]} " =~ " $j " ]] && builtdepspkgs+=("$builtpkg") || builtpkgs+=("$builtpkg")
        done

        # install
        if [[ "$installpkg" || ! "${builtpkgs[*]}" ]]; then
            Note "i" $"Installing ${colorW}${pkgsdeps[$i]}${reset} package(s)..."
            sudo "$pacmanbin" -U --ask 36 ${pacopts[@]/--quiet} --noconfirm -- ${builtdepspkgs[@]} ${builtpkgs[@]}
        fi

        # set dep status
        if [[ $installpkg ]]; then
            for j in "${pkgsdepslist[@]}"; do
                [[ ! " ${aurpkgs[*]} " =~ " $j " ]] && sudo "$pacmanbin" -D "$j" --asdeps &>/dev/null
                [[ "$asdeps" ]] && sudo "$pacmanbin" -D "$j" --asdeps &>/dev/null
                [[ "$asexplicit" ]] && sudo "$pacmanbin" -D "$j" --asexplicit &>/dev/null
            done
        fi
    done

    # remove AUR deps
    if [[ ! $installpkg ]]; then
        [[ "${aurdepspkgs[*]}" ]] && aurdepspkgs=($(expac -Q '%n' "${aurdepspkgs[@]}"))
        [[ "${aurdepspkgs[*]}" ]] && Note "i" $"Removing installed AUR dependencies..." &&
            sudo "$pacmanbin" -Rsn "${aurdepspkgs[@]}" --noconfirm
        # readd removed conflicting packages
        [[ "${aurconflictingpkgsrm[*]}" ]] &&
            sudo "$pacmanbin" -S "${aurconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
        [[ "${repoconflictingpkgsrm[*]}" ]] &&
            sudo "$pacmanbin" -S "${repoconflictingpkgsrm[@]}" --ask 36 --asdeps --needed --noconfirm
    fi

    # remove locks
    rm "${tmpdir:?}/pacaur.build.lck"
    rm -f "${tmpdir:?}/pacaur.sudov.lck"

    # new orphan and optional packages check
    orphanpkgs=($("$pacmanbin" -Qdtq))
    neworphanpkgs=($(CommArr 'oldorphanpkgs' 'orphanpkgs' '-13'))
    for i in "${neworphanpkgs[@]}"; do
        Note "w" $"${colorW}$i${reset} is now an ${colorY}orphan${reset} package"
    done
    optionalpkgs=($("$pacmanbin" -Qdttq))
    optionalpkgs=($(CommArr 'orphanpkgs' 'optionalpkgs' '-13'))
    newoptionalpkgs=($(CommArr 'oldoptionalpkgs' 'optionalpkgs' '-13'))
    for i in "${newoptionalpkgs[@]}"; do
        Note "w" $"${colorW}$i${reset} is now an ${colorY}optional${reset} package"
    done

    # makepkg and install failure check
    if [[ "${errmakepkg[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            Note "f" $"failed to build ${colorW}$i${reset} package(s)"
        done
        exit "$E_PACKAGE_FAILED"
    fi
    [[ "${errinstall[*]}" ]] && exit  "$E_INSTALL_FAILED"
}

CleanCache() {
    local i cachepkgs
    cachedir=($(pacman-conf CacheDir))
    [[ "${cachedir[*]}" ]] && cachedir=("${cachedir[@]%/}") && PKGDEST="${PKGDEST%/}"
    if [[ "$PKGDEST" && ! " ${cachedir[*]} " =~ " $PKGDEST " ]]; then
        [[ "$ccount" -eq 1 ]] && printf "\n%s\n %s\n" $"Packages to keep:" $"All locally installed packages"
        printf "\n%s %s\n" $"AUR cache directory:" "$PKGDEST"
        if [[ "$ccount" -eq 1 ]]; then
            if Proceed "y" $"Do you want to remove all other packages from AUR cache?"; then
                printf "%s\n" $"removing old packages from cache..."
                cachepkgs=("${PKGDEST:?}"/*); cachepkgs=("${cachepkgs[@]##*/}")
                for i in "${cachepkgs[@]%-*}"; do
                    [[ "$i" != "$(expac -Q '%n-%v' "${i%-*-*}")" ]] && rm "${PKGDEST:?}/$i"-*
                done
            fi
        else
            Proceed "n" $"Do you want to remove ALL files from AUR cache?" ||
                printf "%s\n" $"removing all files from AUR cache..." &&
                rm "${PKGDEST:?}"/* &>/dev/null
        fi
    fi

    if [[ -d "$SRCDEST" ]]; then
        [[ "$ccount" -eq 1 ]] &&
            printf "\n%s\n %s\n" $"Sources to keep:" $"All development packages sources"
        printf "\n%s %s\n" $"AUR source cache directory:" "$SRCDEST"
        if [[ "$ccount" -eq 1 ]]; then
            Proceed "y" $"Do you want to remove all non development files from AUR source cache?" &&
                printf "%s\n" $"removing non development files from source cache..." &&
                rm -f "${SRCDEST:?}"/* &>/dev/null
        else
            Proceed "n" $"Do you want to remove ALL files from AUR source cache?" ||
                printf "%s\n" $"removing all files from AUR source cache..." &&
                rm -rf "${SRCDEST:?}"/*
        fi
    fi
    if [[ -d "$clonedir" ]]; then
        if [[ "$ccount" -eq 1 ]]; then
            if [[ ! "${pkgs[*]}" ]]; then
                printf "\n%s\n %s\n" $"Clones to keep:" $"All locally installed clones"
            else
                printf "\n%s\n %s\n" $"Clones to keep:" $"All other locally installed clones"
            fi
        fi
        printf "\n%s %s\n" $"AUR clone directory:" "$clonedir"
        if [[ "$ccount" -eq 1 ]]; then
            foreignpkgsbase=($(expac -Q '%n %e' $("$pacmanbin" -Qmq) |
                awk '{if ($2 == "(null)") print $1; else print $2}'))
            # get target
            if [[ "${pkgs[*]}" ]]; then
                pkgsbase=($(expac -Q '%e' "${pkgs[@]}"))
                aurpkgsbase=($(CommArr 'pkgsbase' 'foreignpkgsbase' '-12'))
                if Proceed "y" $"Do you want to remove ${aurpkgsbase[*]} clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${aurpkgsbase[@]}"; do
                        [[ -d "$clonedir/$i" ]] && rm -rf "${clonedir:?}/$i"
                    done
                fi
            else
                if Proceed "y" $"Do you want to remove all uninstalled clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${clonedir:?}/"*; do
                        [[ -d "$i" && ! " ${foreignpkgsbase[*]} " =~ " $i " ]] &&
                            rm -rf "${clonedir:?}/$i"
                    done
                fi
                if [[ ! "$PKGDEST" || ! "$SRCDEST" ]]; then
                    if Proceed "y" $"Do you want to remove all untracked files from AUR clone directory?"; then
                        printf "%s\n" $"removing untracked files from AUR clone cache..."
                        for i in "${clonedir:?}/"*; do
                            [[ -d "$i" ]] &&
                                git --git-dir="$i/.git" --work-tree="$i" clean -ffdx &>/dev/null
                        done
                    fi
                fi
            fi
        else
            if ! Proceed "n" $"Do you want to remove ALL clones from AUR clone directory?"; then
                printf "%s\n" $"removing all clones from AUR clone cache..."
                for i in "${clonedir:?}/"*; do
                    [[ -d "$i" ]] && rm -rf "$i"
                done
            fi
        fi
    fi
    exit "$E_OK"
}

GetIgnoredPkgs() {
    # global ignoredpkgs
    ignoredpkgs+=($(pacman-conf IgnorePkg))
    ignoredpkgs=("${ignoredpkgs[@]//,/ }")
}

GetIgnoredGrps() {
    # global ignoredgrps
    ignoredgrps+=($(pacman-conf IgnoreGroup))
    ignoredgrps=("${ignoredgrps[@]//,/ }")
}

GetInstallScripts() {
    local installscriptspath
    # global installscripts
    [[ ! -d "$clonedir/$1" ]] && return
    unset installscriptspath installscripts
    installscriptspath=($(find "$clonedir/$1/" -maxdepth 1 -name "*.install"))
    [[ "${installscriptspath[*]}" ]] && installscripts=($(basename -a "${installscriptspath[@]}"))
}

GetBuiltPkg() {
    local ext
    # global builtpkg
    # check PKGEXT suffix first, then default .xz suffix for repository packages in pacman cache
    # and lastly all remaining suffixes in case PKGEXT is locally overridden
    for ext in "$PKGEXT" .pkg.tar{.xz,,.gz,.bz2,.lzo,.lrz,.Z}; do
        builtpkg="$2/$1-${CARCH}${ext}"
        [[ ! -f "$builtpkg" ]] && builtpkg="$2/$1-any${ext}"
        [[ -f "$builtpkg" ]] && break
    done
    [[ ! -f "$builtpkg" ]] && unset builtpkg
}

GetPkgbase() {
    local i
    # global json pkgsbase basepkgs
    SetJson "$@"
    for i in "$@"; do
        pkgsbase+=($(GetJson "$json" "PackageBase" "$i"))
    done
    for i in "${pkgsbase[@]}"; do
        [[ " ${basepkgs[*]} " =~ " $i " ]] || basepkgs+=("$i")
    done
}

declare -A jsoncache
SetJson() {
    if [[ "$#" -eq 0 ]]; then
        json="{}"
    else
        # global json
        [[ "${jsoncache[$@]}" ]] || jsoncache[$@]="$(auracle rawinfo -- "$@")"
        json="${jsoncache[$@]}"
    fi
}

GetJson() {
    local filter="." json="$1" field="$2" pkgname="$3"

    [[ "$pkgname" ]] && filter="select(.Name == \"$pkgname\")"

    jq -rM ".results[] | $filter | select(.$field) .$field | if type==\"array\" then .[] else . end" <<< "$json" 2> /dev/null ||
        Note "e" $"Failed to parse JSON" "$E_FAIL"
}

CheckRequires() {
    local Qrequires=($(expac -Q '%N'))
    if [[ "${Qrequires[*]}" ]]; then
        Note "f" $"failed to prepare transaction (could not satisfy dependencies)"
        Note "e" $"${Qrequires[@]}: requires $@" "$E_INSTALL_DEPS_FAILED"
    fi
}

Proceed() {
    local answer ret

    [[ "$TERM" = dumb || "$cleancache" ]] && local readline=1
    case "$1" in
        y)  printf "${colorB}%s${reset} ${colorW}%s${reset}" "::" "$2 [Y/n] "
            [[ "$noconfirm" ]] && printf '\n' && return 0
            while true; do
                if [[ "$readline" ]]; then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Yy]|'') ret=0; break;;
                    [Nn]) ret=1; break;;
                    *) [[ "$readline" ]] && ret=1 && break;;
                esac
            done;;
        n)  printf "${colorB}%s${reset} ${colorW}%s${reset}" "::" "$2 [y/N] "
            [[ "$noconfirm" ]] && printf '\n' && return 0
            while true; do
                if [[ "$readline" ]]; then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Nn]|'') ret=0; break;;
                    [Yy]) ret=1; break;;
                    *) [[ "$readline" ]] && ret=0 && break;;
                esac
            done;;
    esac
    [[ ! "$readline" ]] && printf '%s\n' "$answer"
    return "$ret"
}

Note() {
    case "$1" in
        i) printf '%b\n' "${colorB}::${reset} $2";;            # info
        w) printf '%b\n' "${colorY}warning:${reset} $2" >&2;;  # warn
        f) printf '%b\n' "${colorR}error:${reset} $2" >&2;;    # fail
        e) printf '%b\n' "${colorR}error:${reset} $2" >&2;     # error
            exit "$3";;
    esac
}

GetLength() {
    local length=0 i
    for i in "$@"; do
        x="${#i}"
        [[ "$x" -gt "$length" ]] && length="$x"
    done
    printf '%s\n' "$length"
}

NothingToDo() {
    [[ ! "$*" ]] && printf '%s\n' $" there is nothing to do" && exit "$E_OK" || return 0
}

SudoV() {
    touch "$tmpdir/pacaur.sudov.lck"
    while [[ -e "$tmpdir/pacaur.sudov.lck" ]]; do
        sudo "$pacmanbin" -V > /dev/null
        sleep 298
    done
}

CommArr() {
    # args are names of 2 arrays and outputs elements that are only in the 2nd
    local array1="$1[@]" array2="$2[@]"
    comm <(printf '%s\n' "${!array1}" | sort -u) <(printf '%s\n' "${!array2}" | sort -u) "$3"
}

trap Cancel INT
Cancel() {
    printf '\n'
    rm -f "${tmpdir:?}"/pacaur.{build,sudov}.lck
    exit
}

Usage() {
    printf "%s\n" $"usage:  pacaur <operation> [options] [target(s)] -- See also pacaur(8)"
    printf "%s\n" $"operations:"
    printf "%s\n" $" pacman extension"
    printf "%s\n" $"   -S, -Ss, -Si, -Sw, -Su, -Qu, -Sc, -Scc"
    printf "%s\n" $"                    extend pacman operations to the AUR"
    printf "%s\n" $" general"
    printf "%s\n" $"   -v, --version    display version information"
    printf "%s\n" $"   -h, --help       display help information"
    printf '\n'
    printf "%s\n" $"options:"
    printf "%s\n" $" pacman extension - can be used with the -S, -Ss, -Si, -Sw, -Su, -Sc, -Scc operations"
    printf "%s\n" $"   -a, --aur        only search, build, install or clean target(s) from the AUR"
    printf "%s\n" $"   -r, --repo       only search, build, install or clean target(s) from the repositories"
    printf "%s\n" $" general"
    printf "%s\n" $"   -e, --edit       edit target(s) PKGBUILD and view install script"
    printf "%s\n" $"   -q, --quiet      show less information for query and search"
    printf "%s\n" $"   --devel          consider AUR development packages upgrade"
    printf "%s\n" $"   --foreign        consider already installed foreign dependencies"
    printf "%s\n" $"   --ignore         ignore a package upgrade (can be used more than once)"
    printf "%s\n" $"   --needed         do not reinstall already up-to-date target(s)"
    printf "%s\n" $"   --noconfirm      do not prompt for any confirmation"
    printf "%s\n" $"   --noedit         do not prompt to edit files"
    printf "%s\n" $"   --rebuild        always rebuild package(s)"
    printf "%s\n" $"   --silent         silence output"
    exit "$E_OK"
}

#
# Main
#

# initialize counters
ccount=0; dcount=0; pac=0

# options
shortopts="DFQRSTUVacdefghiklmnopqrstuvwxy"
longopts=('help' 'database' 'files' 'query' 'remove' 'sync' 'deptest' 'upgrade')
longopts+=('asdeps' 'asexplicit' 'cascade' 'changelog' 'check' 'confirm' 'dbonly' 'debug' 'deps'
           'disable-download-timeout' 'downloadonly' 'explicit' 'file' 'foreign' 'groups' 'info'
           'list' 'machinereadable' 'native' 'needed' 'noconfirm' 'nodeps' 'noprogressbar' 'nosave'
           'noscriptlet' 'owns' 'print' 'recursive' 'refresh' 'regex' 'quiet' 'search' 'sysupgrade'
           'unneeded' 'unrequired' 'upgrades' 'verbose')
longopts+=('arch:' 'assume-installed:' 'cachedir:' 'color:' 'config:' 'dbpath:' 'gpgdir:' 'hookdir:'
           'ignore:' 'ignoregroup:' 'logfile:' 'overwrite:' 'print-format:' 'root:' 'sysroot:')
longopts_aur=('aur' 'by:' 'devel' 'edit' 'literal' 'noedit' 'rebuild' 'repo' 'rsort:' 'searchby:'
              'silent' 'sort:' 'update' 'version')
parseopts "${shortopts}" "${longopts[@]}" "${longopts_aur[@]}" -- "$@" || exit "$E_INVALID_OPTION"
set -- "${OPTRET[@]}"

while true; do
    [[ "$1" = -[cdf-qs-zDFQRSTUV] ]] && pacmanarg+=("$1")
    for i in "${longopts[@]}"; do
        [[ "$1" = "--$i" ]] && pacopts+=("$1")
        [[ "$1": = "--$i" ]] && pacopts+=("$1=$2")
    done
    case "$1" in
        -S|--sync) pacS=1; installpkg=1; operation=sync; ((pac++));;
        -Q|--query) pacQ=1; ((pac++));;
        -s|--search) search=1;;
        -i|--info) info=1;;
        -e|--edit) pace=1;;
        -u|--upgrades|--sysupgrade) upgrade=1; installpkg=1;;
        -q|--quiet) quiet=1; auropts+=("$1");;
        -c|--clean) cleancache=1 && ((ccount++));;
        -n|--native) native=1;;
        -r|--repo) repo=1;;
        -a|--aur) aur=1;;
        --ignore) ignoredpkgs+=("$2"); shift;;
        --color) color="$2"; shift;;
        --literal) auropts+=("$1");;
        --@(by|searchby)) auropts+=("$1=$2"); shift;;
        --sort) sortorder="ascending"; sortby="$2"; shift;;
        --rsort) sortorder="descending"; sortby="$2"; shift;;
        -d|--nodeps) nodeps=1; makeopts+=("$1"); ((dcount++));;
        --assume-installed) assumeinstalled+=("$2"); shift;;
        -[DFRTUV]|--@(database|files|remove|deptest|upgrade)) ((pac++));;
        --@(asdeps|asexplicit|devel|needed|noconfirm|noedit|rebuild)) declare "${1/--}"=1;;
        -[glp]|--@(groups|list|print)) noop=1;;
        -w|--downloadonly) downloadonly=1;;
        --silent) silent=true; pacopts+=("--quiet"); auropts+=("--quiet") makeopts+=("--log");;
        -y|--refresh) refresh=1;;
        -h|--help) help=1;;
        --version) operation=version; ((pac++));;
        -v) ver=1;;
        --) shift; break;;
    esac
    shift
done

# help or version
[[ "$operation" = version ]] || [[ "$pac" -eq 0 && "$ver" ]] && printf '%s\n' "pacaur $version" && exit "$E_OK"
[[ "$pac" -eq 0 && "$help" ]] && Usage

# sorting
case "$sortorder" in
    ascending)  auropts+=("--sort=$sortby");;
    descending) auropts+=("--rsort=$sortby");;
esac

# packages
pkgs=("$@")

# color
if [[ ! "$color" ]]; then
    [[ ! "$(pacman-conf Color)" ]] || [[ "$quiet" && "$search" || "$operation" = upgrades ]] &&
        color=never || color=auto
fi
pacopts+=("--color=$color") && auropts+=("--color=$color")
if [[ ! "$color" = never ]]; then
    reset="\e[0m"; colorR="\e[1;31m"; colorG="\e[1;32m"; colorY="\e[1;33m"
    colorB="\e[1;34m"; colorM="\e[1;35m"; colorW="\e[1;39m"
else
    makeopts+=("--nocolor")
fi

# sanity check
[[ "$aur" ]] && unset refresh
[[ "$pac" -eq 0 && "$pace" ]] && operation=edit
[[ "$pacQ" && "$pace" ]] && pacopts+=("-e")
[[ "$pacQ" && "$upgrade" ]] && operation=upgrades
[[ "$pacS" && "$downloadonly" ]] && unset installpkg
[[ "$pacS" && "$noop" ]] && unset operation
[[ "$pacS" && "$cleancache" ]] && unset search info upgrade
[[ "$pac" -gt 1 ]] && Note "e" $"only one operation may be used at a time" "$E_FAIL"
[[ "$operation" = sync && ! "$search" && ! "$info" && ! "$cleancache" && "$EUID" -eq 0 ]] &&
    Note "e" $"you cannot perform this operation as root" "$E_ROOT"
[[ "$pacS" && "$search" && "$info" ]] &&
    Note "e" $"invalid option: '--info' and '--search' may not be used together" "$E_INVALID_OPTION"
[[ "$(command -v "${editor%% *}")" ]] ||
    Note "e" $"${colorW}\$VISUAL${reset} and ${colorW}\$EDITOR${reset} environment variables not set or defined ${colorW}editor${reset} not found" "$E_MISSING_FILE"
[[ "$PACMAN" = "${0##*/}" ]] &&
    Note "e" $"you cannot use ${colorW}pacaur${reset} as PACMAN environment variable" "$E_FAIL"
[[ -w "$clonedir" ]] ||
    Note "e" $"${colorW}$clonedir${reset} does not have write permission" "$E_FS_PERMISSIONS"
[[ ! "${pkgs[*]}" && ! "${refresh}${upgrade}${cleancache}" && "$operation" =~ (sync|edit) ]] &&
    Note "e" $"no targets specified (use -h for help)" "$E_FAIL"
[[ ! "${pkgs[*]}" && " ${pacmanarg[*]} " =~ ' '-[RU]' ' && ! " ${pacmanarg[*]} " =~ ' -h ' ]] &&
    Note "e" $"no targets specified (use -h for help)" "$E_FAIL"
[[ "$repo" && "$aur" ]] && unset aur repo &&
    Note "w" $"invalid option: '-r/--repo' and '-a/--aur' may not be used together, disabling both"

# operations
case "$operation" in
    edit) # edit (-e) handling
        GetPkgbase "${pkgs[@]}"
        EditPkgs "${pkgsbase[@]}"
        exit;;
    sync)
        # search (-Ss, -s) handling
        if [[ "$search" ]]; then
            if [[ ! "$aur" ]]; then
                if [[ "$refresh" ]]; then
                    sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}
                else
                    "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}
                fi
                exitrepo=$?
            fi
            if [[ ! "$repo" ]]; then
                auracle search ${auropts[@]} -- ${pkgs[@]}
                exitaur=$?
            fi
            # exit code
            [[ "$exitrepo" = 0 || "$exitaur" = 0 ]] && exit "$E_OK" || exit "$E_FAIL"
        # info (-Si, -i) handling
        elif [[ "$info" ]]; then
            if [[ ! "${pkgs[*]}" ]]; then
                "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]}
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                [[ "$refresh" ]] && sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} ${repopkgs[@]}
                [[ ! "$refresh" ]] && "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} ${repopkgs[@]}
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                [[ "$refresh" && ! "${repopkgs[*]}" ]] && sudo "$pacmanbin" -Sy ${pacopts[@]}
                [[ ! "$aur" ]] &&
                    Note "i" $"Package(s) ${colorW}${aurpkgs[*]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
                auracle info "${auropts[@]}" -- "${aurpkgs[@]}"
            fi
        # clean (-Sc) handling
        elif [[ "$cleancache" ]]; then
            [[ ! "$aur" ]] && sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} ${repopkgs[@]}
            [[ ! "$repo" ]] && CleanCache "${pkgs[@]}"
        # sysupgrade (-Su, -u) handling
        elif [[ "$upgrade" ]]; then
            [[ "${pkgs[*]}" ]] && ClassifyPkgs "${pkgs[@]}"
            if [[ ! "$aur" ]]; then
                sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} ${repopkgs[@]}
                (($?>0)) && [[ "$repo" ]] && exit "$E_FAIL"
            fi
            if [[ "${aurpkgs[*]}" && ! "$aur" ]]; then
                Note "i" $"Package(s) ${colorW}${aurpkgs[*]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
            fi
            [[ ! "$repo" ]] && Core
        # sync (-S, -y), downloadonly (-Sw, -m), refresh (-Sy)
        else
            if [[ ! "${pkgs[*]}" ]]; then
                sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]}
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            [[ "${repopkgs[*]}" ]] && sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} ${repopkgs[@]}
            if [[ "${aurpkgs[*]}" ]]; then
                [[ "$refresh" && ! "${repopkgs[*]}" ]] && sudo "$pacmanbin" -Sy ${pacopts[@]}
                [[ ! "$aur" ]] && Note "i" $"Package(s) ${colorW}${aurpkgs[*]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
                Core
            fi
        fi
        exit;;
    upgrades) # upgrades (-Qu) handling
        [[ "$aur" ]] || "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}; exitrepo=$?
        if [[ ! "$repo" && ! "$native" ]]; then
            if [[ ! "${pkgs[*]}" ]]; then
                auracle sync ${auropts[@]} $("$pacmanbin" -qm ${pacmanarg[@]//-u} ${pacopts[@]//--upgrades})
            else
                auracle sync ${auropts[@]} -- ${pkgs[@]}
            fi
            exitaur=$?
        fi
        [[ "$exitrepo" = 0 || "$exitaur" = 0 ]] && exit "$E_OK" || exit "$E_FAIL";;
    *) if [[ " ${pacmanarg[*]} " =~ ' -F ' && " ${pacmanarg[*]} " =~ ' -y ' ]]; then
            sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}
        elif [[ ! "${pkgs[*]}" ]] ||
            [[ " ${pacmanarg[*]} " =~ ' '-[DFQTglp]' ' && ! "${asdeps}${asexplicit}" ]]; then
            "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}
        else
            sudo "$pacmanbin" ${pacmanarg[@]} ${pacopts[@]} -- ${pkgs[@]}
        fi
        exit;; # others operations handling
esac

# vim:set ts=4 sw=4 et:
